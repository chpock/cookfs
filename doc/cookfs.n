'\"
'\" Generated from file 'cookfs\&.man' by tcllib/doctools with format 'nroff'
'\" Copyright (c) 2010-2011 Wojciech Kocjan <wojciech@kocjan\&.org>
'\" Copyright (c) 2024 Konstantin Kushnir <chpock@gmail\&.com>
'\"
.TH "cookfs" n 1\&.5\&.0 cookfs "vfs::cookfs"
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.BS
.SH NAME
cookfs \- vfs::cookfs
.SH SYNOPSIS
package require \fBTcl 8\&.5\fR
.sp
package require \fBvfs::cookfs ?1\&.5\&.0?\fR
.sp
\fB::cookfs::Mount\fR ?\fIoptions\fR? \fIarchive\fR \fIlocal\fR ?\fIoptions\fR?
.sp
\fB::vfs::cookfs::Mount\fR ?\fIoptions\fR? \fIarchive\fR \fIlocal\fR ?\fIoptions\fR?
.sp
\fB::cookfs::Unmount\fR \fBfsid\fR
.sp
\fIcookfsHandle\fR \fBaside\fR \fIfilename\fR
.sp
\fIcookfsHandle\fR \fBwritetomemory\fR
.sp
\fIcookfsHandle\fR \fBoptimizelist\fR \fIbase\fR \fIfilelist\fR
.sp
\fIcookfsHandle\fR \fBgetmetadata\fR \fIparameterName\fR ?\fIdefaultValue\fR?
.sp
\fIcookfsHandle\fR \fBsetmetadata\fR \fIparameterName\fR \fIvalue\fR
.sp
\fIcookfsHandle\fR \fBwriteFiles\fR ?\fIfilename1\fR \fItype1\fR \fIdata1\fR \fIsize1\fR ?\fIfilename2\fR \fItype2\fR \fIdata2\fR \fIsize2\fR ?\fI\&.\&.\fR???
.sp
\fIcookfsHandle\fR \fBfilesize\fR
.sp
\fIcookfsHandle\fR \fBsmallfilebuffersize\fR
.sp
.BE
.SH DESCRIPTION
Package \fBvfs::cookfs\fR is a Tcl virtual filesystem (VFS) that allows
storing one or more files in a single file\&. This is similar to mk4vfs, zipvfs
and many other archive formats\&.
.PP
The main difference is that cookfs was designed for Tcl-related use and is
optimized for both shipping Tcl scripts as well as delivering large payloads
in an efficient way\&.
.SH COMMANDS
.TP
\fB::cookfs::Mount\fR ?\fIoptions\fR? \fIarchive\fR \fIlocal\fR ?\fIoptions\fR?
.TP
\fB::vfs::cookfs::Mount\fR ?\fIoptions\fR? \fIarchive\fR \fIlocal\fR ?\fIoptions\fR?
Mounts cookfs archive\&. Archive is read from \fIarchive\fR and can later be accessed from Tcl using \fIlocal\fR as mount point\&. Options can preceed or succeed \fIarchive\fR and \fIlocal\fR arguments\&.
.sp
The command returns a cookfs handle which is also a command that can be used to perform certain actions on cookfs archive\&.
.sp
For definition of available options, see \fBMOUNT OPTIONS\fR\&.
.TP
\fB::cookfs::Unmount\fR \fBfsid\fR
Unmounts a cookfs archive\&. This is called internally by tclvfs\&. Command \fBvfs::unmount\fR should be used to unmount Tcl archives, not \fBcookfs::Unmount\fR directly\&.
.sp
For cookfs archives it is very important to properly unmount them after performing all operations as many changes are only stored on unmount operation\&.
.TP
\fIcookfsHandle\fR \fBaside\fR \fIfilename\fR
Uses a separate file for storing changes to an archive\&. This can be used to keep changes for a read-only archive in a separate file\&.
.sp
See \fBASIDE AND WRITE TO MEMORY\fR for more details on aside files and how they can be used\&.
.TP
\fIcookfsHandle\fR \fBwritetomemory\fR
Stores all further changes to this archive only in memory\&.
This can be used to store temporary data or applying changes that do not persist across cookfs filesystem remounts and/or application restarts\&.
.sp
See \fBASIDE AND WRITE TO MEMORY\fR for more details on write to memory feature\&.
.TP
\fIcookfsHandle\fR \fBoptimizelist\fR \fIbase\fR \fIfilelist\fR
Takes a list of files and optimizes them to reduce number of pages read by cookfs\&.
This is mainly useful when unpacking very large number of files\&.
.sp
Parameter \fIbase\fR specifies path to be prepended when getting file information\&.
When list of files is relative to archive root, \fIbase\fR should be empty\&.
When \fIfilelist\fR contains paths relative to subdirectory of archive root,
\fIbase\fR should specify path to this subdirectory\&.
.sp
For example if archive contains files
\fBcontents/dir1/file1\fR and \fBcontents/dir1/subdir/file2\fR, the following code can be used:
Specifying \fIfilelist\fR relative to a directory and proper \fIbase\fR:
.CS


% puts [$fsid optimizelist contents/dir1 {file1 subdir/file2}]
subdir/file2
file1

.CE
.IP
Specifying \fIfilelist\fR relative to root directory:
.CS


% puts [$fsid optimizelist "" {contents/dir1/file1 contents/dir1/subdir/file2}]
contents/dir1/subdir/file2
contents/dir1/file1

.CE
.TP
\fIcookfsHandle\fR \fBgetmetadata\fR \fIparameterName\fR ?\fIdefaultValue\fR?
Gets a parameter from cookfs metadata\&. If \fIparameterName\fR is currently set in metadata, value for it is returned\&.
.sp
If  \fIparameterName\fR is not currently set, \fIdefaultValue\fR is returned if it was specified\&.
If \fIdefaultValue\fR was not specified and parameter is not set, an error is thrown\&.
.sp
See \fBCOOKFS METADATA\fR for more details on metadata storage in cookfs archives\&.
.TP
\fIcookfsHandle\fR \fBsetmetadata\fR \fIparameterName\fR \fIvalue\fR
Set \fIparameterName\fR to specified \fIvalue\fR\&. If parameter currently exists, it is overwritten\&.
.sp
See \fBCOOKFS METADATA\fR for more details on metadata storage in cookfs archives\&.
.TP
\fIcookfsHandle\fR \fBwriteFiles\fR ?\fIfilename1\fR \fItype1\fR \fIdata1\fR \fIsize1\fR ?\fIfilename2\fR \fItype2\fR \fIdata2\fR \fIsize2\fR ?\fI\&.\&.\fR???
Write one or more files to cookfs archive\&. Specified as list of one or more 4-element entries describing files\&.
Each \fIfilename\fR specifies name of the file, relative to archive root\&.
Elements \fItype\fR and \fIdata\fR specify source for adding a file as well as actual data\&.
\fISize\fR specifies size of the file\&. If specified as empty string, it is calculated based on \fItype\fR\&.
.sp
The following values for \fItype\fR are accepted:
.RS
.IP \(bu
\fBfile\fR -
\fIdata\fR specifies path to file that should be put in the cookfs archive; path is relative to current working directory, same as for command such as \fBfile copy\fR;
file is copied directly and does not require staging file in memory, unlike writing a file in cookfs archive using \fBopen\fR
.IP \(bu
\fBdata\fR -
\fIdata\fR is data to be stored in file as binary
.IP \(bu
\fBchannel\fR -
\fIdata\fR is a valid Tcl channel that should be read by cookfs;
channel is read from current location until end or until \fIsize\fR bytes have been read
.RE
.TP
\fIcookfsHandle\fR \fBfilesize\fR
Returns size of file up to last stored page\&.
The size only includes page sizes and does not include overhead for index and additional information used by cookfs\&.
.TP
\fIcookfsHandle\fR \fBsmallfilebuffersize\fR
Returns size of all files that are queued up to be written\&.
.PP
.SH "MOUNT OPTIONS"
The following options can be specified when mounting a cookfs archive:
.TP
\fB-readonly\fR
Mount archive as read-only\&. Archive must exist and be a valid cookfs archive, otherwise mount will fail\&.
.TP
\fB-writetomemory\fR
Enable write to memory feature for this mount\&.
.sp
See \fBASIDE AND WRITE TO MEMORY\fR for more details on write to memory feature\&.
.TP
\fB-pagesize\fR \fIbytes\fR
Specifies maximum size of a page\&. This specifies how much bytes a chunk
(storing entire file, part of a file or multiple files) can be\&.
Setting larger values increases memory usage, but may increase compression ratio,
especially for compressors such as bzip2 or LZMA, which compress larger chunks
of information more efficiently\&.
.sp
See \fBCOOKFS STORAGE\fR for more details on how cookfs stores files, index and metadata\&.
.TP
\fB-pagecachesize\fR \fInumPages\fR
Maximum number of pages to be stored in memory when reading data from cookfs archive\&.
If 0, no cache is used\&. Otherwise, up to \fInumPages\fR are kept in memory for efficient access\&.
Increasing the value directly affects speed of reading operations, but also increases
memory\&.
.sp
Maximum number of memory used for cache is number of pages to cache multiplied by
maximum size of a page\&.
.sp
See \fBCOOKFS STORAGE\fR for more details on how cookfs stores files, index and metadata\&.
.TP
\fB-smallfilesize\fR \fIbytes\fR
Specifies threshold for small files\&. All files smaller than this value are treated as small files
and are stored and compressed as multiple files for efficiency\&.
.sp
See \fBCOOKFS STORAGE\fR for more details on how cookfs stores files, index and metadata\&.
.TP
\fB-smallfilebuffer\fR \fIbytes\fR
Specifies maximum buffer for small files\&. Specifying larger value allows
storing more files in memory before saving them on disk\&. This can produce
better compression ratio\&.
.sp
See \fBCOOKFS STORAGE\fR for more details on how cookfs stores files, index and metadata\&.
.TP
\fB-volume\fR
Register mount point as Tcl volume - useful for creating mount points in locations that do not exist - such as \fIarchive://\fR\&.
.TP
\fB-compression\fR \fInone|zlib|bzip2|xz|custom\fR
Compression to use for storing new files\&.
.sp
See \fBCOMPRESSSION\fR for more details on compression in cookfs\&.
.TP
\fB-compresscommand\fR \fItcl command\fR
For \fIcustom\fR compression, specifies command to use for compressing pages\&.
.sp
See \fBCOMPRESSSION\fR for more details on compression in cookfs\&.
.TP
\fB-decompresscommand\fR \fItcl command\fR
For \fIcustom\fR compression, specifies command to use for decompressing pages\&.
.sp
See \fBCOMPRESSSION\fR for more details on compression in cookfs\&.
.TP
\fB-endoffset\fR \fIoffset\fR
Read archive starting at specified offset, instead of reading from end of file\&.
.sp
This feature is used when cookfs archive is not stored at end of file - for example if it is
used in tclkit and followed by mk4vfs archive\&.
.TP
\fB-setmetadata\fR \fIlist\fR
Set specified metadata after mounting\&. Convenience for setting metadata in mount command\&.
List should be a name-value pairs list indicating parameter names and values to set\&.
.TP
\fB-noregister\fR
Do not register this mount point with tclvfs\&. Mainly for internal use\&.
.TP
\fB-nocommand\fR
Do not register Tcl command for this cookfs handle\&. Mainly for internal use\&.
.TP
\fB-bootstrap\fR \fItcl code\fR
Bootstrap code for cookit binaries\&. Mainly for internal use\&.
.TP
\fB-pagehash\fR \fIhash\fR
Hash function to use for comparing if pages are equal\&. This is mainly used as pre-check and entire page is still checked for\&.
Defaults to \fBmd5\fR, can also be \fBcrc32\fR\&. Mainly for internal/testing at this moment\&. Do not use\&.
.TP
\fB-fsindexobject\fR \fIfsiagesObject\fR
Do not create cookfs::fsindex object, use specified fsindex object\&. Mainly for internal use\&.
.TP
\fB-pagesobject\fR \fIpagesObject\fR
Do not create cookfs::pages object, use specified pages object\&. Mainly for internal use\&.
.PP
.SH "COOKFS STORAGE"
Cookfs uses \fBcookfs::pages\fR for storing all files and
directories in an archive\&. Information on which pages store what files is stored
in \fBcookfs::fsindex\fR object, that is stored as part of archive\&.
.PP
Cookfs stores files in one of the following ways:
.IP [1]
Entire file is stored in a single cookfs page\&.
This happens if file's size is larger than \fI-smallfilesize\fR,
but smaller than \fI-pagesize\fR\&.
.IP [2]
Entire file is stored in multiple cookfs pages\&.
This happens if file's size is larger than \fI-smallfilesize\fR,
and larger than \fI-pagesize\fR\&.
.IP [3]
Multiple files are stored in a single cookfs page\&.
This happens if file's size is smaller than \fI-smallfilesize\fR\&.
.PP
First and second case are similar and a limit on page size is mainly
used to allow faster seek operations and increate I/O operation speed\&.
.PP
When compressing large files as a single stream (such as in zipvfs and mk4vfs),
seeking operation requires re-reading and ignoring all data up to new location\&.
With this approach, seek operations are instant since only new pages are read
and data prior to new seek location is ignored\&.
.PP
Storing multiple files in a single page is used to increase compression
ratio for multiple small files - such as Tcl scripts\&. All small files
(whose size does not exceed \fI-smallfilesize\fR) are grouped by
their extension, followed by their file name\&. This allows files such as
\fBpkgIndex\&.tcl\fR to be compressed in same page, which is much more efficient
than compressing each of them independantly\&.
.SH COMPRESSSION
Cookfs uses compression to store pages and filesystem index more efficiently\&.
Pages are compressed as a whole and independant of files\&. Filesystem index is
also compressed to reduce file size\&.
.PP
Compression is specified as \fI-compression\fR option when mounting an archive\&.
This option applies to newly stored pages and whenever a file index should be
saved\&. Existing pages are not re-compressed on compression change\&.
.PP
Cookfs provides the following compressions:
.IP \(bu
\fBnone\fR -
no compression is used at all; mainly used for testing purposes or when
content should not be packed at all
.IP \(bu
\fBzlib\fR -
use zlib compression to compress - same as with mk4vfs and zipvfs
.IP \(bu
\fBbz2\fR -
use bzip2 for compression; requires specifying \fB--enable-bz2\fR when building
cookfs
.IP \(bu
\fBxz\fR -
use xz for compression; requires specifying \fB--enable-xz\fR when building
cookfs
.IP \(bu
\fBcustom\fR -
use Tcl commands for compressing and decompressing pages
.PP
For \fBcustom\fR compression, \fI-compresscommand\fR and \fI-decompresscommand\fR
have to be specified\&. These commands will be used to compress data and will be called
with data to be compressed or decompressed as additional argument\&.
.PP
For example the following are sample compress and decompress commands:
.CS


# use vfs::zip to (de)compress data and encode it in HEX
proc testc {d} {
    binary scan [vfs::zip -mode compress $d] H* rc
    return "HEXTEST-$rc"
}
proc testd {d} {
    set rc [vfs::zip -mode decompress [binary format H* [string range $d 8 end]]]
    return $rc
}

vfs::cookfs::Mount archive archive -compression custom -compresscommand testc -decompresscommand testd

.CE
.PP
See \fBCOOKFS STORAGE\fR for more details on how files are stored in cookfs\&.
.PP
Default values for \fI-pagesize\fR, \fI-smallfilesize\fR and
\fI-smallfilebuffer\fR parameters provided by cookfs have been chosen carefully\&.
These are outcome of performing multiple tests\&.
It is not recommended to change it for \fBzlib\fR compression\&.
.SH "COOKFS METADATA"
Cookfs supports storing metadata in an archive\&. Metadata are any number of
properties stored in a cookfs archive\&.
.PP
Cookfs does not impose any limits or rules on naming of properties as well as
possible values, but it is recommended that cookfs internal properties are stored
using \fBcookfs\&.*\fR prefix and cookit related properties use
\fBcookit\&.*\fR format\&.
.PP
User properties do not need to use any prefix or suffix, but it is recommended
to use form of \fB\fIappname\fR\&.*\fR\&.
.SH "ASIDE AND WRITE TO MEMORY"
Cookfs supports a feature called aside changes\&. It stores all changes
in a separate file\&. It can be used for updating files in read-only archives such
as standalone binaries or data on read-only media\&.
.PP
Aside functionality can be enabled for read-only and read-write archives\&.
All types of changes can be performed and they will be stored in the new file\&.
Operations such as deletions from a file are also possible\&.
.PP
Aside changes are persistent\&. It is possible to mount an archive, setup an aside
file and perform changes and unmount it\&. When remounting the archive, changes will
not be visible\&. However, after enabling aside and pointing to same file as before,
changes will instantly be visible\&.
.PP
Aside changes do not cause increased use of memory - changes are written to disk in same
fashion, using new file instead of the original one\&.
.PP
Write to memory feature is slightly different\&. It allows read-only and read-write
archives to store all changes in memory and those will not be saved back on disk\&.
This feature is mainly intended for handling temporary files or running legacy code that
requires write access to files inside a read-only archive\&.
.SH CACHING
In order to make I/O operations with pages more efficient and avoid additional
page read attempts, a page cache is used\&.
.PP
Generally, pages that contain more than one file are more interesting to cache\&.
For these pages, it is more likely that they will be needed to read
the following files\&.
.PP
To provide higher priority caching for pages with many files, each cache entry
has a "weight" field\&. The value of this field is 0 for pages that contain data
from only one file\&. And the value of this field is 1 if this page contains
data from multiple files\&. According to this field, the priority for storing
pages in the cache will be implemented\&. When replacing pages in the cache,
the page with the minimum weight is replaced first\&.
.PP
However, another issue arises with this approach\&. There may be a situation
where a page with several files will be stored in the cache, but access to
these files is no longer needed\&. In this case, the cached page will reside
in the cache and prevent more used pages from being added\&.
.PP
To solve this issue, each cache entry also has an "age" field\&. The "age"
field is a special value that is incremented by 1 during page operations\&.
When this value reaches a certain limit, the page weight is reset to the
default value of 0\&. Also, if the page is requested from the cache and used,
the value of its "age" will be reset to the original value 0\&.
.PP
This makes it possible to free up cache space from prioritized but unused pages\&.
.PP
The concept of "age" has the following nuances:
.PP
It is possible to read a file splitted into a large number of pages\&. To avoid
adding "age" multiple times for all cache elements when reading each page,
"age" for all items will be incremented only on the very first attempt to
read this file\&.
.PP
The opposite situation is possible, when a single page contains a large number
of small files\&. To avoid "age" overflow for other pages when reading these files,
the field "age" will only increase the first time this page is read\&. If this page
already exists in the cache, then the field "age" for cache items
will not be increased\&.
.SH "SEE ALSO"
cookfs_fsindex, cookfs_pages
.SH KEYWORDS
cookfs, vfs
.SH COPYRIGHT
.nf
Copyright (c) 2010-2011 Wojciech Kocjan <wojciech@kocjan\&.org>
Copyright (c) 2024 Konstantin Kushnir <chpock@gmail\&.com>

.fi
