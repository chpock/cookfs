source [file join [file dirname [info script]] common.tcl]

test cookfsVfs-1.1.1.1 "Mount empty filename (unix)" -constraints {unix tcl86} -body {
    cookfs::Mount "" ""
} -match glob -error {Unable to create Cookfs object: couldn't open "*": illegal operation on a directory}

test cookfsVfs-1.1.1.2 "Mount empty filename (unix)" -constraints {unix tcl90} -body {
    cookfs::Mount "" ""
} -match glob -error {Unable to create Cookfs object: couldn't open "*": is a directory}

test cookfsVfs-1.1.2 "Mount empty filename (windows)" -constraints win -body {
    cookfs::Mount "" ""
} -match glob -error {Unable to create Cookfs object: couldn't open "*": permission denied}

test cookfsVfs-1.2 "Mount non-existant file as read-write" -setup {
    set file [makeFile {} cookfs.cfs]
    variable fsid
} -body {
    set fsid [cookfs::Mount $file $file]
    cookfs::Unmount $file
    set fsid
} -match glob -result {::cookfs::*::vfs::mount*}

test cookfsVfs-1.3 "Mount non-existant file as read-only" -setup {
    set file [makeFile {} cookfs.cfs]
} -body {
    cookfs::Mount -readonly $file $file
} -cleanup {
    catch { cookfs::Unmount $file }
} -error {Unable to create Cookfs object: signature not found}

test cookfsVfs-1.4 "Remounting archive" -setup {
    set file [makeFile {} cookfs.cfs]
} -body {
    cookfs::Mount $file $file
    makeBinFile {} testfile $file
    cookfs::Unmount $file

    cookfs::Mount $file $file
    file exists [file join $file testfile]
} -cleanup {
    cookfs::Unmount $file
} -result 1

test cookfsVfs-1.5 "Remounting archive using -pagesobject" -constraints {enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    variable p
    variable h
} -body {
    cookfs::Mount $file $file
    makeBinFile {} testfile $file
    cookfs::Unmount $file

    set p [cookfs::pages $file]
    set h [cookfs::Mount $file $file -pagesobject $p]
    string equal [$h getpages] $p
} -cleanup {
    cookfs::Unmount $file
} -result 1

test cookfsVfs-1.6 "Remounting archive using -fsindexobject" -constraints {enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    variable p
    variable i
    variable h
} -body {
    cookfs::Mount $file $file
    makeBinFile {} testfile $file
    cookfs::Unmount $file

    set p [cookfs::pages $file]
    set i [cookfs::fsindex [$p index]]
    set h [cookfs::Mount $file $file -pagesobject $p -fsindexobject $i]
    string equal [$h getindex] $i
} -cleanup {
    cookfs::Unmount $file
} -result 1

test cookfsVfs-1.7 "Setting metadata on mount" -setup {
    set file [makeFile {} cookfs.cfs]
    variable h
} -body {
    cookfs::Mount $file $file
    makeBinFile {} testfile $file
    cookfs::Unmount $file

    set h [cookfs::Mount $file $file -setmetadata {test1 1 test2 2}]
    cookfs::Unmount $file

    set h [cookfs::Mount $file $file]
    assertEq [$h getmetadata test1] 1
    assertEq [$h getmetadata test2] 2
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-1.8.1 "Mounting as volume, unmount with vfs::unmount" -constraints {packageTclvfs enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    variable h
} -body {
    cookfs::Mount $file $file -compression none
    makeBinFile {} testfile $file
    cookfs::Unmount $file

    set h [cookfs::Mount $file test:/ -volume]
    assertGe [lsearch -exact [file volumes] test:/] 0
    # don't change this to cookfs::Unmount. Here we test vfs::unmount
    vfs::unmount test:/
} -cleanup {
    catch { vfs::unmount $file }
    catch { vfs::unmount test:/ }
} -ok

test cookfsVfs-1.8.2 "Mounting as volume, unmount with cookfs::Unmount" -setup {
    set file [makeFile {} cookfs.cfs]
    variable h
} -body {
    cookfs::Mount $file $file -compression none
    makeBinFile {TEST} testfile $file
    cookfs::Unmount $file

    set h [cookfs::Mount $file test:/ -volume]
    assertGe [lsearch -exact [file volumes] test:/] 0
    cookfs::Unmount test:/
} -cleanup {
    catch { cookfs::Unmount $file }
    catch { cookfs::Unmount test:/ }
} -ok

test cookfsVfs-1.8.3 "Mounting multiple volumes, unmounting a single volume" -setup {
    set file [makeFile {} cookfs.cfs]
} -body {
    cookfs::Mount $file $file -compression none
    makeBinFile {TEST} testfile $file
    cookfs::Unmount $file

    cookfs::Mount $file test1:/ -volume
    cookfs::Mount $file test2:/ -volume
    cookfs::Mount $file test3:/ -volume

    assertGe [lsearch -exact [file volumes] test1:/] 0
    assertGe [lsearch -exact [file volumes] test2:/] 0
    assertGe [lsearch -exact [file volumes] test3:/] 0

    cookfs::Unmount test2:/

    assertGe [lsearch -exact [file volumes] test1:/] 0
    assertEq [lsearch -exact [file volumes] test2:/] -1
    assertGe [lsearch -exact [file volumes] test3:/] 0

    cookfs::Unmount test1:/

    assertEq [lsearch -exact [file volumes] test1:/] -1
    assertEq [lsearch -exact [file volumes] test2:/] -1
    assertGe [lsearch -exact [file volumes] test3:/] 0

    cookfs::Unmount test3:/

    assertEq [lsearch -exact [file volumes] test1:/] -1
    assertEq [lsearch -exact [file volumes] test2:/] -1
    assertEq [lsearch -exact [file volumes] test3:/] -1
} -cleanup {
    catch {cookfs::Unmount $file}
    catch {cookfs::Unmount test1:/}
    catch {cookfs::Unmount test2:/}
    catch {cookfs::Unmount test3:/}
} -ok

test cookfsVfs-1.8.4.1.1 "Mounting as volume, glob results, -directory" -setup {
    set img [makeFile {} cookfs.cfs]
    set mnt "test:/"
} -body {
    cookfs::Mount $img $mnt -compression none -volume
    makeBinFile {} testfile $mnt
    # TODO: it is a hack to pass temporary Tcl object as an argument
    # for the -directory parameter to avoid memory leak report.
    # See TODO item for details.
    glob -directory [string range $mnt 0 end] *
} -cleanup {
    cookfs::Unmount $mnt
} -result {test:/testfile}

test cookfsVfs-1.8.4.1.2 "Mounting as volume, glob results, -tails -directory" -setup {
    set img [makeFile {} cookfs.cfs]
    set mnt "test:/"
} -body {
    cookfs::Mount $img $mnt -compression none -volume
    makeBinFile {} testfile $mnt
    # TODO: it is a hack to pass temporary Tcl object as an argument
    # for the -directory parameter to avoid memory leak report.
    # See TODO item for details.
    glob -directory [string range $mnt 0 end] -tails *
} -cleanup {
    cookfs::Unmount $mnt
} -result {testfile}

test cookfsVfs-1.8.4.2.1 "Mounting as volume, glob results, -path" -setup {
    set img [makeFile {} cookfs.cfs]
    set mnt "test:/"
} -body {
    cookfs::Mount $img $mnt -compression none -volume
    makeBinFile {} testfile $mnt
    glob -path "${mnt}test" *
} -cleanup {
    cookfs::Unmount $mnt
} -result {test:/testfile}

test cookfsVfs-1.8.4.2.2 "Mounting as volume, glob results, -tails -path" -setup {
    set img [makeFile {} cookfs.cfs]
    set mnt "test:/"
} -body {
    cookfs::Mount $img $mnt -compression none -volume
    makeBinFile {} testfile $mnt
    glob -path "${mnt}test" -tails *
} -cleanup {
    cookfs::Unmount $mnt
} -result {testfile}

test cookfsVfs-1.9 "Test storing same files" -constraints {enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    variable h
} -body {
    cookfs::Mount $file $file -smallfilesize 40960
    makeFile [string repeat "TEST"    64] [file join $file test1a]
    makeFile [string repeat "TEST"  1024] [file join $file test2a]
    makeFile [string repeat "TEST"    64] [file join $file test1b]
    makeFile [string repeat "TEST" 16384] [file join $file test4a]
    makeFile [string repeat "TEST"  4096] [file join $file test3a]
    makeFile [string repeat "TEST"  1024] [file join $file test2b]
    makeFile [string repeat "TEST"  4096] [file join $file test3b]
    makeFile [string repeat "TEST" 16384] [file join $file test4b]
    cookfs::Unmount $file

    set h [cookfs::Mount $file $file -readonly]
    assertTrue [fsindexEqual [[$h getindex] get test4a] [[$h getindex] get test4b]]
    assertTrue [fsindexEqual [[$h getindex] get test3a] [[$h getindex] get test3b]]
    assertTrue [fsindexEqual [[$h getindex] get test2a] [[$h getindex] get test2b]]
    assertTrue [fsindexEqual [[$h getindex] get test1a] [[$h getindex] get test1b]]
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-2.1 "Test compressing entire directory structure" -setup {
    set dir [makeDirectory cookfs.vfs]
    makeSimpleTree $dir
    set file [makeFile {} cookfs.cfs]
} -body {
    cookfs::Mount $file $file
    file copy -force $dir [file join $file vfs]
    testIfEqual $dir [file join $file vfs]
} -cleanup {
    cookfs::Unmount $file
} -result 1

test cookfsVfs-2.2 "Test compressing entire directory structure after remount" -setup {
    set dir [makeDirectory cookfs.vfs]
    makeSimpleTree $dir
    set file [makeFile {} cookfs.cfs]
} -body {
    cookfs::Mount $file $file
    file copy -force $dir [file join $file vfs]
    cookfs::Unmount $file
    cookfs::Mount $file $file
    testIfEqual $dir [file join $file vfs]
} -cleanup {
    cookfs::Unmount $file
} -result 1

test cookfsVfs-2.3 "Test correct storing of empty files or new directory as only change in existing cookfs" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
    makeBinFile [string repeat TEST 1024] file1 $file
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount $file $file]
    # create 2 files so length of new index is not smaller than previously
    makeBinFile {} file2 $file
    makeBinFile {} file34 $file
    cookfs::Unmount $file

    set fsid [cookfs::Mount $file $file]
    assertTrue [file exists $file/file2] "Unable to find file2 in archive"
    # create 2 directories so length of new index is not smaller than previously
    file mkdir $file/dir1
    file mkdir $file/dir23
    cookfs::Unmount $file

    set fsid [cookfs::Mount $file $file]
    assertTrue [file exists $file/dir1] "Unable to find dir1 in archive"
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-3.1 "Test creating files in non-existant directory in VFS" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
} -body {
    close [open $file/somedir/file w]
} -cleanup {
    cookfs::Unmount $file
} -match glob -error "*no such file or directory*"

test cookfsVfs-3.2 "Test creating files in file in VFS" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
} -body {
    close [open $file/file w]
    close [open $file/file/otherfile w]
} -cleanup {
    cookfs::Unmount $file
} -match glob -error "*not a directory*"

test cookfsVfs-3.3.1 "Test creating directories in file in VFS" -constraints tcl86 -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
} -body {
    close [open $file/file w]
    file mkdir $file/file/somedir
} -cleanup {
    cookfs::Unmount $file
} -match glob -error "*file already exists*"

test cookfsVfs-3.3.2 "Test creating directories in file in VFS" -constraints tcl90 -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
} -body {
    close [open $file/file w]
    file mkdir $file/file/somedir
} -cleanup {
    cookfs::Unmount $file
} -match glob -error "*file exists*"

test cookfsVfs-3.4 "Test creating directories and files" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
} -body {
    file mkdir $file/dir1
    file mkdir $file/dir2
    file mkdir $file/dir2/dir3
    close [open $file/file2 w]
    close [open $file/dir2/file4 w]
    close [open $file/dir2/dir3/file5 w]
    cookfs::Unmount $file
    set fsid [cookfs::Mount $file $file]
    assertEq [lsort [glob -tails -directory $file * */* */*/*]] \
        {dir1 dir2 dir2/dir3 dir2/dir3/file5 dir2/file4 file2}
    assertEq [lsort [glob -tails -directory $file -type d -nocomplain * */* */*/*]] \
        {dir1 dir2 dir2/dir3}
    assertEq [lsort [glob -tails -directory $file -type f -nocomplain * */* */*/*]] \
        {dir2/dir3/file5 dir2/file4 file2}
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-4.2 "Test add-aside feature using fsid aside command" -constraints cookfsAside -setup {
    set file [makeFile {} cookfs.cfs]
    set file2 [makeFile {} cookfs2.cfs]
    set fsid [cookfs::Mount $file $file]
    close [open $file/file1 w]
    file mkdir $file/dir1
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount -readonly $file $file]
    $fsid aside $file2
    file mkdir $file/dir2
    close [open $file/file2 w]
    cookfs::Unmount $file

    set fsid [cookfs::Mount -readonly $file $file]
    $fsid aside $file2
    lsort [glob -directory $file -tails *]
} -cleanup {
    cookfs::Unmount $file
} -result {dir1 dir2 file1 file2}

test cookfsVfs-4.4 "Test write to memory feature using fsid writetomemory command" -constraints cookfsAside -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
    close [open $file/file1 w]
    file mkdir $file/dir1
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount -readonly $file $file]
    $fsid writetomemory
    file mkdir $file/dir2
    close [open $file/file2 w]
    cookfs::Unmount $file

    set fsid [cookfs::Mount -readonly $file $file]
    lsort [glob -directory $file -tails *]
} -cleanup {
    cookfs::Unmount $file
} -result {dir1 file1}

test cookfsVfs-5.1 "Test getting metadata using fsid getmetadata command without default value" -constraints cookfsMetadata -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount -readonly $file $file]
    $fsid getmetadata nonexistant
} -cleanup {
    cookfs::Unmount $file
} -error {Parameter not defined}

test cookfsVfs-5.2 "Test getting metadata using fsid getmetadata command with default value" -constraints cookfsMetadata -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount -readonly $file $file]
    $fsid getmetadata nonexistant 12
} -cleanup {
    cookfs::Unmount $file
} -result {12}

test cookfsVfs-5.3 "Test setting metadata using fsid setmetadata command" -constraints cookfsMetadata -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
} -body {
    $fsid setmetadata somename othervalue
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-5.4 "Test setting metadata in a read-only mount" -constraints cookfsMetadata -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount -readonly $file $file]
    $fsid setmetadata somename othervalue
} -cleanup {
    cookfs::Unmount $file
} -error {Archive is read-only}

test cookfsVfs-5.5 "Test setting and getting metadata" -constraints cookfsMetadata -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
    $fsid setmetadata somename othervalue
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount -readonly $file $file]
    $fsid getmetadata somename
} -cleanup {
    cookfs::Unmount $file
} -result {othervalue}

test cookfsVfs-6.1 "Test crc32 based VFS and page handling" -constraints {cookfsMetadata enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    variable h
} -body {
    cookfs::Mount -pagehash crc32 $file $file
    makeBinFile {TEST TEST} test1 $file
    cookfs::Unmount $file

    cookfs::Mount $file $file
    makeBinFile {TEST TEST} test2 $file
    cookfs::Unmount $file

    set h [cookfs::Mount $file $file -readonly]
    [$h getpages] length
} -cleanup {
    cookfs::Unmount $file
} -result {1}

test cookfsVfs-7.1 "Test filesize command" -setup {
    set file [makeBinFile [string repeat "TEST" 1024] pages.cfs]
    set fsid [cookfs::Mount -smallfilesize 8192 -compression none $file $file]
} -body {
    makeBinFile [string repeat "Test0001" 4096] testfile1 $file
    makeBinFile [string repeat "Test0002" 4096] testfile2 $file
    $fsid filesize
} -cleanup {
    cookfs::Unmount $file
} -result 69647

test cookfsVfs-7.2 "Test smallfilebuffersize command" -setup {
    set file [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount -smallfilesize 8192 -compression none $file $file]
} -body {
    makeBinFile [string repeat "Test0001" 4096] testfile1 $file
    makeBinFile [string repeat "Test0002" 4096] testfile2 $file
    makeBinFile [string repeat "Test0002" 128] testfile3 $file
    $fsid smallfilebuffersize
} -cleanup {
    cookfs::Unmount $file
} -result 1024

test cookfsVfs-8.1 "Test modifying file mtime" -setup {
    set file [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount -compression none $file $file]
} -body {
    makeBinFile [string repeat "Test0001" 4096] testfile1 $file
    file mtime [file join $file testfile1] 1
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    assertEq [file mtime [file join $file testfile1]] 1 "Invalid mtime after first pass"
    file mtime [file join $file testfile1] 1342177280
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    file mtime [file join $file testfile1]
} -cleanup {
    cookfs::Unmount $file
} -result 1342177280

test cookfsVfs-9.1 "Test deleting files" -setup {
    set file [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount -compression none $file $file]
} -body {
    close [open [file join $file testfile1] w]
    close [open [file join $file testfile2] w]
    file mkdir [file join $file testdir1]
    file mkdir [file join $file testdir2]
    close [open [file join $file testdir2/testfile3] w]
    close [open [file join $file testdir2/testfile4] w]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    file delete -force [file join $file testfile1]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    join [lsort [glob -tails -directory $file * */*]] ,
} -cleanup {
    cookfs::Unmount $file
} -result {testdir1,testdir2,testdir2/testfile3,testdir2/testfile4,testfile2}

test cookfsVfs-9.2 "Test deleting empty directories" -setup {
    set file [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount -compression none $file $file]
} -body {
    close [open [file join $file testfile1] w]
    close [open [file join $file testfile2] w]
    file mkdir [file join $file testdir1]
    file mkdir [file join $file testdir2]
    close [open [file join $file testdir2 testfile3] w]
    close [open [file join $file testdir2 testfile4] w]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    file delete -force [file join $file testdir1]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    join [lsort [glob -tails -directory $file * */*]] ,
} -cleanup {
    cookfs::Unmount $file
} -result {testdir2,testdir2/testfile3,testdir2/testfile4,testfile1,testfile2}

test cookfsVfs-9.3 "Test deleting non-empty directories" -setup {
    set file [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount -compression none $file $file]
} -body {
    close [open [file join $file testfile1] w]
    close [open [file join $file testfile2] w]
    file mkdir [file join $file testdir1]
    file mkdir [file join $file testdir2]
    close [open [file join $file testdir2 estfile3] w]
    close [open [file join $file testdir2 testfile4] w]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    file delete -force [file join $file testdir2]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    join [lsort [glob -tails -directory $file * */*]] ,
} -cleanup {
    cookfs::Unmount $file
} -result {testdir1,testfile1,testfile2}

test cookfsVfs-9.4 "Test deleting non-empty directories with complex structure" -setup {
    set file [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount -compression none $file $file]
} -body {
    close [open [file join $file testfile1] w]
    close [open [file join $file testfile2] w]
    file mkdir [file join $file testdir1]
    file mkdir [file join $file testdir2]
    file mkdir [file join $file testdir2 testdir3]
    file mkdir [file join $file testdir2 testdir3 testdir4]
    close [open [file join $file testdir2 testfile3] w]
    close [open [file join $file testdir2 testfile4] w]
    close [open [file join $file testdir2 testdir3 testfile5] w]
    close [open [file join $file testdir2 testdir3 testfile6] w]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    file delete -force [file join $file testdir2]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    join [lsort [glob -tails -directory $file * */*]] ,
} -cleanup {
    cookfs::Unmount $file
} -result {testdir1,testfile1,testfile2}

test cookfsVfs-10.1.1 "Test changing compression without remounting, with custom compression" -constraints {
    enabledTclCmds enabledTclCallbacks
} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fc
    variable idx
    set fsid [cookfs::Mount $file $file -compression custom -smallfilesize 32768 \
        -compresscommand testcompressraw -decompresscommand testdecompressraw -alwayscompress]
} -body {
    $fsid compression zlib
    assertEq [$fsid compression] "zlib" "Getting compression does not return 'zlib'"

    makeBinFile [string repeat "TEST" 256] testfile1 $file

    $fsid compression none
    assertEq [$fsid compression] "none" "Getting compression does not return 'none'"

    makeBinFile [string repeat "test" 256] testfile2 $file

    $fsid compression custom
    assertEq [$fsid compression] "custom" "Getting compression does not return 'custom'"
    cookfs::Unmount $file

    set fsid [cookfs::Mount $file $file -readonly \
        -compresscommand testcompressraw -decompresscommand testdecompressraw -alwayscompress]
    set idx [[$fsid getpages] index]
    cookfs::Unmount $file

    set fc [viewBinFile $file]

    assertNotContain $fc [string repeat "TEST" 256] "File testfile1 should be compressed"
    assertContain $fc [string repeat "test" 256] "File testfile2 should not be compressed"
    assertContain $fc [testcompressraw $idx] "Index not found"
} -cleanup {
    catch { cookfs::Unmount $file }
    testrawcleanup
} -ok

test cookfsVfs-10.1.2 "Test changing compression without remounting, with custom compression" -constraints {
    enabledTclCmds enabledCPages
} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fc
    variable idx
    set fsid [cookfs::Mount $file $file -compression lzma -smallfilesize 32768 -alwayscompress]
} -body {
    $fsid compression zlib
    assertEq [$fsid compression] "zlib" "Getting compression does not return 'zlib'"

    makeBinFile [string repeat "TEST" 256] testfile1 $file

    $fsid compression none
    assertEq [$fsid compression] "none" "Getting compression does not return 'none'"

    makeBinFile [string repeat "test" 256] testfile2 $file

    $fsid compression lzma
    assertEq [$fsid compression] "lzma" "Getting compression does not return 'lzma'"
    cookfs::Unmount $file

    set fc [viewBinFile $file]

    assertNotContain $fc [string repeat "TEST" 256] "File testfile1 should be compressed"
    assertContain $fc [string repeat "test" 256] "File testfile2 should not be compressed"
} -cleanup {
    catch { cookfs::Unmount $file }
    testrawcleanup
} -ok

test cookfsVfs-11.1 "Test unmount using fsid" -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    cookfs::Unmount $fsid
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { cookfs::Unmount $file }
} -ok

test cookfsVfs-11.2 "Test unmount using mount point" -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    cookfs::Unmount $file
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { cookfs::Unmount $file }
} -ok

test cookfsVfs-11.3 "Test unmount using mount point (relative)" -setup {
    set file pages.cfs
    # make sure no additional data is written to file
    close [open $file w]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    cookfs::Unmount $file
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { cookfs::Unmount $file }
    file delete $file
} -ok

test cookfsVfs-11.4 "Test unmount using vfs::unmount" -constraints {packageTclvfs enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [vfs::cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    vfs::unmount $file
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { vfs::unmount $file }
} -ok

test cookfsVfs-12.1 "Test registration in tclvfs, should be registered by default" -constraints {packageTclvfs enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [vfs::cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    # Don't change this to cookfs::Unmount. This test checks vfs::unmount command.
    # vfs::unmount should unmount cookfs successfully.
    vfs::unmount $file
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { vfs::unmount $file }
} -ok

# Run this test with c-vfs only, as tcl-vfs will not work if cookfs is not registered with tclvfs.
test cookfsVfs-12.2 "Test registration in tclvfs, should not be registered due to -noregister" -constraints { enabledCVfs packageTclvfs enabledTclCmds } -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [vfs::cookfs::Mount -noregister $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    # this should fail
    assertErrMsgMatch { vfs::unmount $file } {can't read "_unmountCmd(*)": no such element in array}
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    # this has to be successful
    cookfs::Unmount $fsid
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { cookfs::Unmount $fsid }
} -ok

test cookfsVfs-12.3 "Test that cookfs::Unmount invoked with fsid unregister cookfs in tclvfs" -constraints { packageTclvfs enabledTclCmds } -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [vfs::cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    # this has to be successful
    cookfs::Unmount $fsid
    assertEq [file type $file] "file"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 0
    # this should fail with:
    # can't read "_unmountCmd(/w/projects/build/_cookfs/_tmp/pages.cfs)": no such element in array
    # because cookfs::Unmount unregistered cookfs from tclvfs
    assertErrMsgMatch { vfs::unmount $file } {can't read "_unmountCmd(*)": no such element in array}
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { cookfs::Unmount $fsid }
} -ok

test cookfsVfs-12.4 "Test that cookfs::Unmount invoked with mount path unregister cookfs in tclvfs" -constraints { packageTclvfs enabledTclCmds } -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [vfs::cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    # this has to be successful
    cookfs::Unmount $file
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
    # this should fail with:
    # can't read "_unmountCmd(/w/projects/build/_cookfs/_tmp/pages.cfs)": no such element in array
    # because cookfs::Unmount unregistered cookfs from tclvfs
    assertErrMsgMatch { vfs::unmount $file } {can't read "_unmountCmd(*)": no such element in array}
    assertEq [file type $file] "file"
} -cleanup {
    catch { cookfs::Unmount $fsid }
} -ok

test cookfsVfs-13.1 "Test -bootstrap option for cookfs::Mount, when opening new archive" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    set bootstrap "TEST BOOTSTRAP"
    variable fsid
} -body {
    set fsid [cookfs::Mount -bootstrap $bootstrap $file $file]
    cookfs::Unmount $file
    set fsid [cookfs::Mount $file $file -readonly]
    assertEq [[$fsid getpages] get 0] $bootstrap
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-13.2 "Test -bootstrap option for cookfs::Mount is ignored, when opening existing archive" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    set bootstrap "TEST BOOTSTRAP"
    variable fsid
} -body {
    set fsid [cookfs::Mount -bootstrap $bootstrap $file $file]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -bootstrap "XXXX" $file $file]
    assertEq [[$fsid getpages] get 0] $bootstrap
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-13.3 "Test -bootstrap option for cookfs::Mount, ignore empty bootstrap" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    set fsid [cookfs::Mount -bootstrap "" $file $file]
    [$fsid getpages] length
} -cleanup {
    cookfs::Unmount $file
} -result 0

test cookfsVfs-14.1 "Test -pagehash option for cookfs::Mount, when opening new archive (md5)" -constraints { enabledCPages enabledTclCmds } -setup {
    set file [makeBinFile {} pages.cfs]
    set hash "md5"
    variable fsid
} -body {
    set fsid [cookfs::Mount -pagehash $hash $file $file]
    assertEq [[$fsid getpages] hash] $hash
    assertEq [[$fsid getindex] getmetadata cookfs.pagehash] $hash
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-14.2 "Test -pagehash option for cookfs::Mount, when opening new archive (crc32)" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    set hash "crc32"
    variable fsid
} -body {
    set fsid [cookfs::Mount -pagehash $hash $file $file]
    assertEq [[$fsid getpages] hash] $hash
    assertEq [[$fsid getindex] getmetadata cookfs.pagehash] $hash
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-14.3 "Test -pagehash option for cookfs::Mount, when reopening (md5)" -constraints { enabledCPages enabledTclCmds } -setup {
    set file [makeBinFile {} pages.cfs]
    set hash "md5"
    variable fsid
} -body {
    cookfs::Mount -pagehash $hash $file $file
    # make sure that archive is not empty, so hash algo will not reset after reopen
    makeFile {} temp1 $file
    cookfs::Unmount $file
    set fsid [cookfs::Mount $file $file]
    assertEq [[$fsid getpages] hash] $hash
    assertEq [[$fsid getindex] getmetadata cookfs.pagehash] $hash
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-14.4 "Test -pagehash option for cookfs::Mount, when reopening (crc32)" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    set hash "crc32"
    variable fsid
} -body {
    cookfs::Mount -pagehash $hash $file $file
    # make sure that archive is not empty, so hash algo will not reset after reopen
    makeFile {} temp1 $file
    cookfs::Unmount $file
    set fsid [cookfs::Mount $file $file]
    assertEq [[$fsid getpages] hash] $hash
    assertEq [[$fsid getindex] getmetadata cookfs.pagehash] $hash
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-14.5 "Test -pagehash option for cookfs::Mount is ignored, when opening existing archive" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    set hash "crc32"
    variable fsid
} -body {
    cookfs::Mount -pagehash $hash $file $file
    # make sure that archive is not empty
    makeFile {} temp1 $file
    cookfs::Unmount $file
    set fsid [cookfs::Mount -pagehash "md5" $file $file]
    assertEq [[$fsid getpages] hash] $hash
    assertEq [[$fsid getindex] getmetadata cookfs.pagehash] $hash
} -cleanup {
    cookfs::Unmount $file
} -ok

# Here we just check if "<fsindex> getmetadata cookfs.pagehash" ends with an error.
# Actual values are not interested.
test cookfsVfs-14.6 "Test that cookfs.pagehash metadata exists by default" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    set fsid [cookfs::Mount $file $file]
    [$fsid getindex] getmetadata cookfs.pagehash
    # make sure that archive is not empty
    makeFile {} temp1 $file
    cookfs::Unmount $file
    set fsid [cookfs::Mount $file $file]
    [$fsid getindex] getmetadata cookfs.pagehash
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-14.7 "Test that cookfs.pagehash metadata matches actual pages hash" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    set fsid [cookfs::Mount $file $file]
    assertEq [[$fsid getpages] hash] [[$fsid getindex] getmetadata cookfs.pagehash]
    # make sure that archive is not empty
    makeFile {} temp1 $file
    cookfs::Unmount $file
    set fsid [cookfs::Mount $file $file]
    assertEq [[$fsid getpages] hash] [[$fsid getindex] getmetadata cookfs.pagehash]
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-14.8 "Test unknown hash value" -setup {
    set file [makeBinFile {} pages.cfs]
} -body {
    set fsid [cookfs::Mount -pagehash foo $file $file]
} -cleanup {
    catch { cookfs::Unmount $file }
} -error {bad hash "foo": must be md5 or crc32}

test cookfsVfs-15.1 "Test optimizelist with empty base" -constraints {enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none \
        -smallfilesize 0x10 -smallfilebuffer 0x30 -pagesize 0x10]
    makeSimpleTree2 $file
    makeSimpleTree2 $file/subtree1
    makeBinFile "ABCD" diff $file/subtree1
    cookfs::Unmount $file
    variable h
    variable files
} -body {
    set h [cookfs::Mount $file $file]
    set files [$h optimizelist "" [getFilesRelative $file]]
    # Verify the result.
    join [testOptimizedList "" $files [$h getindex]] \n
} -cleanup {
    cookfs::Unmount $file
} -result {}

test cookfsVfs-15.2 "Test optimizelist with non-empty base" -constraints {enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none \
        -smallfilesize 0x10 -smallfilebuffer 0x30 -pagesize 0x10]
    makeSimpleTree2 $file
    makeSimpleTree2 $file/subtree1
    makeBinFile "ABCD" diff $file/subtree1
    cookfs::Unmount $file
    variable h
    variable files
} -body {
    set h [cookfs::Mount $file $file]
    set files [$h optimizelist "subtree1" [getFilesRelative $file/subtree1]]
    # Verify the result.
    join [testOptimizedList "subtree1" $files [$h getindex]] \n
} -cleanup {
    cookfs::Unmount $file
} -result {}

# Attributes will work only for c-vfs

test cookfsVfs-16.1.1 "Test set attributes for root" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
} -body {
    file attributes $file -vfs 2
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-vfs" is read-only}

test cookfsVfs-16.1.2 "Test list attributes for root" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set expected {
        -archive -cachesize -compression -fileset -handle -metadata -pages
        -parts -readonly -relative -smallfilebuffersize -vfs -volume
        -writetomemory
    }
    if { [testConstraint cookfsCrypto] } {
        lappend expected {*}{
            -encryptkey -encryptlevel -password
        }
    }
    if { [testConstraint threaded] } {
        lappend expected -shared
    }
} -body {
    assertEq [lsort [dict keys [file attributes $file]]] [lsort $expected]
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-16.1.3 "Test get attributes for root" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
} -body {
    assertEq [file attributes $file -vfs] 1
    assertEq [file attributes $file -handle] $fsid
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-16.1.4 "Test get unknown attribute for root" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
} -body {
    file attributes $file -foo
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -match glob -error {bad option "-foo": must be *}

test cookfsVfs-16.1.5 "Test -handle attribute for root when vfs created with -nocommand" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none -nocommand]
} -body {
    file attributes $file -handle
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result {}

test cookfsVfs-16.2.1 "Test set attributes for file" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set file2 [makeBinFile "" test $file]
} -body {
    file attributes $file2 -vfs 2
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-vfs" is read-only}

test cookfsVfs-16.2.2 "Test list attributes for file" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set file2 [makeBinFile "" test $file]
} -body {
    lsort [dict keys [file attributes $file2]]
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result {-blocks -compression -compsize -mount -pending -relative -uncompsize -vfs}

test cookfsVfs-16.2.3 "Test get attributes for file" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set file2 [makeBinFile "" test $file]
} -body {
    assertEq [file attributes $file2 -vfs] 1
    assertErrMsg { file attributes $file2 -handle } {bad option "-handle": must be -vfs, -uncompsize, -compsize, -compression, -mount, -pending, -blocks, or -relative}
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-16.2.4 "Test get unknown attribute for file" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set file2 [makeBinFile "" test $file]
} -body {
    file attributes $file2 -foo
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -error {bad option "-foo": must be -vfs, -uncompsize, -compsize, -compression, -mount, -pending, -blocks, or -relative}

test cookfsVfs-16.3.1 "Test set attributes for directory" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set dir [makeDirectory test $file]
} -body {
    file attributes $dir -vfs 2
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-vfs" is read-only}

test cookfsVfs-16.3.2 "Test list attributes for directory" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set dir [makeDirectory test $file]
} -body {
    lsort [dict keys [file attributes $dir]]
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result {-mount -relative -vfs}

test cookfsVfs-16.3.3 "Test get attributes for directory" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set dir [makeDirectory test $file]
} -body {
    assertEq [file attributes $dir -vfs] 1
    assertErrMsg { file attributes $dir -handle } {bad option "-handle": must be -vfs, -mount, or -relative}
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-16.3.4 "Test get unknown attribute for directory" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set dir [makeDirectory test $file]
} -body {
    file attributes $dir -foo
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -error {bad option "-foo": must be -vfs, -mount, or -relative}

test cookfsVfs-17.1 "Test in-memory vfs, open with a file" -setup {
    set dir [makeDirectory cookfs.vfs]
    makeSimpleTree2 $dir
    set file [makeBinFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -writetomemory \
        -smallfilesize 0x10 -smallfilebuffer 0x30 -pagesize 0x10]
} -body {
    file copy -force $dir [file join $file vfs]
    assertTrue [testIfEqual $dir [file join $file vfs]]
    cookfs::Unmount $file
    assertEq [file size $file] 0
} -cleanup {
    catch { cookfs::Unmount $file }
} -ok

test cookfsVfs-17.2 "Test in-memory vfs, open without a file" -setup {
    set dir [makeDirectory cookfs.vfs]
    makeSimpleTree2 $dir
    set mnt "/mountpoint"
    set fsid [cookfs::Mount $mnt -writetomemory \
        -smallfilesize 0x10 -smallfilebuffer 0x30 -pagesize 0x10]
} -body {
    file copy -force $dir [file join $mnt vfs]
    assertTrue [testIfEqual $dir [file join $mnt vfs]]
    cookfs::Unmount $mnt
} -cleanup {
    catch { cookfs::Unmount $mnt }
} -ok

test cookfsVfs-17.3 "Test in-memory vfs, open existing archive" -setup {
    set dir [makeDirectory cookfs.vfs]
    makeSimpleTree2 $dir
    set file [makeBinFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none \
        -smallfilesize 0x10 -smallfilebuffer 0x30 -pagesize 0x10]
    file copy -force $dir [file join $file vfs]
    cookfs::Unmount $file
    set file2 [makeBinFile {} cookfs2.cfs]
    file copy -force $file $file2
} -body {
    set fsid [cookfs::Mount $file $file -writetomemory \
        -smallfilesize 0x10 -smallfilebuffer 0x30 -pagesize 0x10]
    assertTrue [testIfEqual $dir [file join $file vfs]]
    makeSimpleTree2 $file/subdirX
    cookfs::Unmount $file
    # Compare archive $file with its copy $file2 to make sure it hasn't changed.
    assertTrue [testIfEqual $file $file2]
} -cleanup {
    catch { cookfs::Unmount $file }
} -ok

test cookfsVfs-18.1 "Test that fsindex/pages are available when their\
     commands are deleted, but they are bound to existing VFS" -constraints {enabledTclCmds enabledCVfs} -setup {
    set file [makeBinFile {} cookfs.cfs]
    variable p
    variable i
    variable file2
} -body {
    set p [cookfs::pages -compression none $file]
    set i [cookfs::fsindex]
    cookfs::Mount $file $file -pagesobject $p -fsindexobject $i
    # delete pages/index commands
    rename $p ""
    rename $i ""
    # try to add a file
    set file2 [makeBinFile TEST01 test $file]
    cookfs::Unmount $file
    cookfs::Mount $file $file -readonly
    viewBinFile $file2
} -cleanup {
    cookfs::Unmount $file
} -result TEST01

test cookfsVfs-19.1 "Check if VFS is available in child interp" -setup {
    set file [makeBinFile {} cookfs.cfs]
    set i [interp create]
    interp eval $i [list set file $file]
} -body {
    cookfs::Mount $file $file -compression none
    interp eval $i [list file attributes $file -vfs]
} -cleanup {
    interp delete $i
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result 1

test cookfsVfs-19.2.1 "Check if files can be copied to VFS in the child interp (small file)" -setup {
    set file [makeBinFile {} cookfs.cfs]
    set file2 [makeBinFile {TEST01} test]
    set i [interp create]
    interp eval $i [list set file $file]
    interp eval $i [list set file2 $file]
} -body {
    cookfs::Mount $file $file -compression none -smallfilesize 1024 -smallfilebuffer 2048 -pagesize 1024
    interp eval $i [list file copy $file2 [file join $file test]]
    viewBinFile [file join $file test]
} -cleanup {
    interp delete $i
    cookfs::Unmount $file
} -result TEST01

test cookfsVfs-19.2.2 "Check if files can be copied to VFS in the child interp (big file)" -setup {
    set file [makeBinFile {} cookfs.cfs]
    set file2 [makeBinFile {TEST02} test]
    set i [interp create]
    interp eval $i [list set file $file]
    interp eval $i [list set file2 $file]
} -body {
    cookfs::Mount $file $file -compression none -smallfilesize 1 -smallfilebuffer 0 -pagesize 1024
    interp eval $i [list file copy $file2 [file join $file test]]
    viewBinFile [file join $file test]
} -cleanup {
    interp delete $i
    cookfs::Unmount $file
} -result TEST02

test cookfsVfs-19.3 "Check if mount handler is available in child interp" -constraints {enabledCVfs enabledTclCmds} -setup {
    set file [makeBinFile {} cookfs.cfs]
    set i [interp create]
    interp eval $i [list set file $file]
} -body {
    cookfs::Mount $file $file -compression none
    interp eval $i {
        [file attributes $file -handle] filesize
    }
} -cleanup {
    interp delete $i
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-19.4 "Check if pages handler is available in child interp" -constraints {enabledCVfs enabledTclCmds} -setup {
    set file [makeBinFile {} cookfs.cfs]
    set i [interp create]
    interp eval $i [list set file $file]
} -body {
    cookfs::Mount $file $file -compression none
    interp eval $i {
        [[file attributes $file -handle] getpages] length
    }
} -cleanup {
    interp delete $i
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-19.5 "Check if fsindex handler is available in child interp" -constraints {enabledCVfs enabledTclCmds} -setup {
    set file [makeBinFile {} cookfs.cfs]
    set i [interp create]
    interp eval $i [list set file $file]
} -body {
    cookfs::Mount $file $file -compression none
    interp eval $i {
        set result [[[file attributes $file -handle] getindex] get ""]
        # as "" is VFS root, we expect only one element
        # after 'get ""' - directory mtime
        expr { [string is wideinteger -strict $result] ? "ok" : $result }
    }
} -cleanup {
    interp delete $i
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result ok

test cookfsVfs-19.6.1 "Check mount/unmount in child interp" -setup {
    set file [makeBinFile {} cookfs.cfs]
    set i [interp create]
    interp eval $i [list set file $file]
} -body {
    interp eval $i {
        package require cookfs
        cookfs::Mount $file $file -compression none
    }
    assertEq [file type $file] "directory"
    interp eval $i {
        cookfs::Unmount $file
    }
    assertEq [file type $file] "file"
} -cleanup {
    interp delete $i
    catch { cookfs::Unmount $file }
} -ok

test cookfsVfs-19.6.2 "Check unmount in child interp after interp died" -setup {
    set file [makeBinFile {} cookfs.cfs]
    set i [interp create]
    interp eval $i [list set file $file]
} -body {
    interp eval $i {
        package require cookfs
        cookfs::Mount $file $file -compression none
    }
    assertEq [file type $file] "directory"
    interp delete $i
    assertEq [file type $file] "file"
} -cleanup {
    catch { interp delete $i }
    catch { cookfs::Unmount $file }
} -ok

# This test is related to cookfsVfs-20.1.2. If something needs to be changed here,
# the appropriate changes should be added to cookfsVfs-20.1.2.
test cookfsVfs-20.1.1 "Don't crash when stamp is not present" -setup {
    # base compression + base compression level + encryption
    set data [binary format ccc 0 0 0]
    # pgindex
    # compression + compression level + 16 bytes hash + compressed size + uncompressed size
    append data [binary format ccc16II 0 0 \
        {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0} \
        0 0]
    # fsindex
    # compression + compression level + 16 bytes hash + compressed size + uncompressed size
    append data [binary format ccc16II 0 0 \
        {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0} \
        0 0]
    append data "CFS0003"
    set file [makeBinFile $data pages.cfs]
} -body {
    cookfs::Mount $file $file -readonly
} -cleanup {
    catch { cookfs::Unmount $file }
} -error {Unable to create Cookfs object: file does not contain enough bytes for all pages}

# This test differs from the previous one in that there is no byte representing
# the compression level in the tail of the archive
test cookfsVfs-20.1.2 "Don't crash when stamp is not present and archive suffix is malformed" -setup {
    # base compression + encryption
    set data [binary format cc 0 0]
    # pgindex
    # compression + compression level + 16 bytes hash + compressed size + uncompressed size
    append data [binary format ccc16II 0 0 \
        {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0} \
        0 0]
    # fsindex
    # compression + compression level + 16 bytes hash + compressed size + uncompressed size
    append data [binary format ccc16II 0 0 \
        {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0} \
        0 0]
    append data "CFS0003"
    set file [makeBinFile $data pages.cfs]
} -body {
    cookfs::Mount $file $file -readonly
} -cleanup {
    catch { cookfs::Unmount $file }
} -error {Unable to create Cookfs object: index not found}

test cookfsVfs-21.1 "Open a file that starts as a mount point without an error" -setup {
    set cfs [makeBinFile {} pages.cfs]
    set checkfile1 [makeFile {OUTSIDE} pages.cfs.test]
    variable checkfile2
} -body {
    cookfs::Mount $cfs $cfs -compression none
    set checkfile2 [makeFile {INSIDE} test $cfs]
    assertEq [viewFile $checkfile1] OUTSIDE
    assertEq [viewFile $checkfile2] INSIDE
} -cleanup {
    cookfs::Unmount $cfs
} -ok

test cookfsVfs-22.1.1 "Verify VFS mount point with a filesystem separator at the end" -setup {
    set cfs [makeBinFile {} pages.cfs]
    set mnt "mount:/"
} -body {
    cookfs::Mount $cfs $mnt -compression none -volume
    makeFile {INSIDE} test $mnt
    viewFile "${mnt}test"
} -cleanup {
    cookfs::Unmount $mnt
} -result {INSIDE}

test cookfsVfs-22.1.2 "Verify VFS mount point with a filesystem separator at the end (using join)" -setup {
    set cfs [makeBinFile {} pages.cfs]
    set mnt "mount:/"
} -body {
    cookfs::Mount $cfs $mnt -compression none -volume
    makeFile {INSIDE} test $mnt
    viewFile [file join $mnt "test"]
} -cleanup {
    cookfs::Unmount $mnt
} -result {INSIDE}

test cookfsVfs-22.2.1 "Verify VFS mount point with 2 filesystem separators at the end" -setup {
    set cfs [makeBinFile {} pages.cfs]
    set mnt "mount://"
} -body {
    cookfs::Mount $cfs $mnt -compression none -volume
    makeFile {INSIDE} test $mnt
    viewFile "${mnt}test"
} -cleanup {
    cookfs::Unmount $mnt
} -result {INSIDE}

test cookfsVfs-22.2.2 "Verify VFS mount point with 2 filesystem separators at the end (using join)" -setup {
    set cfs [makeBinFile {} pages.cfs]
    set mnt "mount://"
} -body {
    cookfs::Mount $cfs $mnt -compression none -volume
    makeFile {INSIDE} test $mnt
    viewFile [file join $mnt "test"]
} -cleanup {
    cookfs::Unmount $mnt
} -result {INSIDE}

test cookfsVfs-23.1.1 "Test fileset, missing argument to -fileset" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
} -body {
    cookfs::Mount $cfs $cfs -fileset
} -cleanup {
    catch { cookfs::Unmount $cfs }
} -error {missing argument to -fileset option}

test cookfsVfs-23.2.1 "Test fileset, attributes for fileset-disabled / fileset-enabled VFS" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [file attributes $cfs -fileset] {}
    file attribute $cfs -fileset foo
    assertEq [file attributes $cfs -fileset] {foo}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.3.1.1 "Test fileset, RO VFS, open non-fileset VFS with -fileset" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
    # Make sure VFS is not empty
    makeBinFile {} test $cfs
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly -fileset foo
} -cleanup {
    catch { cookfs::Unmount $cfs }
} -error {error when selecting a fileset: cannot set a fileset to a non-empty fsindex without an initialized fileset}

test cookfsVfs-23.3.1.2 "Test fileset, RO VFS, set attribute for non-fileset VFS" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
    # Make sure VFS is not empty
    makeBinFile {} test $cfs
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly
    file attributes $cfs -fileset foo
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {cannot set a fileset to a non-empty fsindex without an initialized fileset}

test cookfsVfs-23.3.2.1 "Test fileset, RO VFS, open fileset VFS with unknown -fileset" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -fileset foo
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly -fileset bar
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -error {error when selecting a fileset: VFS does not have the required fileset "bar", it cannot be created due to read-only mode}

test cookfsVfs-23.3.2.2 "Test fileset, RO VFS, set wrong attribute for fileset VFS" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -fileset foo
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly
    file attributes $cfs -fileset qux
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {VFS does not have the required fileset "qux", it cannot be created due to read-only mode}

test cookfsVfs-23.3.3.1 "Test fileset, RO VFS, open fileset VFS with known -fileset" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -fileset foo
    file attributes $cfs -fileset qux
    file attributes $cfs -fileset bar
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly -fileset qux
    assertEq [lindex [file attributes $cfs -fileset] 0] qux
    lsort [file attributes $cfs -fileset]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {bar foo qux}

test cookfsVfs-23.3.3.2 "Test fileset, RO VFS, set known attribute for fileset VFS" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -fileset foo
    file attributes $cfs -fileset qux
    file attributes $cfs -fileset bar
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly
    assertEq [lindex [file attributes $cfs -fileset] 0] foo
    file attributes $cfs -fileset bar
    assertEq [lindex [file attributes $cfs -fileset] 0] bar
    lsort [file attributes $cfs -fileset]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {bar foo qux}

test cookfsVfs-23.4.1 "Test fileset, switch filesets on RW VFS" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
} -body {
    cookfs::Mount $cfs $cfs -fileset foo

    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {}
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.4.2 "Test fileset, switch filesets on RO VFS" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -fileset foo
    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs
    file attributes $cfs -fileset bar
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs
    cookfs::Unmount $cfs
} -body {

    # The 1st fileset by default: foo
    cookfs::Mount $cfs $cfs -readonly

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}

    cookfs::Unmount $cfs

    # Mount with specific fileset: bar
    cookfs::Mount $cfs $cfs -readonly -fileset bar

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.5.1 "Test fileset, aside, current fileset is preserved" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    set file2 [makeFile {} cookfs2.cfs]
    set fsid [cookfs::Mount $cfs $cfs -fileset foo]
} -body {

    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs

    file attributes $cfs -fileset bar
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs

    $fsid aside $file2

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.5.2 "Test fileset, aside, current fileset is preserved, add a file" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    set file2 [makeBinFile {} cookfs2.cfs]
    set fsid [cookfs::Mount $cfs $cfs -fileset foo]
} -body {

    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs

    file attributes $cfs -fileset bar
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs

    $fsid aside $file2
    makeBinFile {bar_test3} "bar_test3" $cfs

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2 bar_test3}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
    assertEq [viewBinFile "bar_test3" $cfs] {bar_test3}

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2 bar_test3}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
    assertEq [viewBinFile "bar_test3" $cfs] {bar_test3}

} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.5.3.1 "Test fileset, aside, RO VFS, current fileset is preserved" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    set file2 [makeBinFile {} cookfs2.cfs]
    set fsid [cookfs::Mount $cfs $cfs -fileset foo]
    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs
    file attributes $cfs -fileset bar
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs
    cookfs::Unmount $cfs
} -body {

    set fsid [cookfs::Mount $cfs $cfs -readonly]

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    $fsid aside $file2

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.5.3.2 "Test fileset, aside, RO VFS, current fileset is preserved, add a file" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    set file2 [makeBinFile {} cookfs2.cfs]
    set fsid [cookfs::Mount $cfs $cfs -fileset foo]
    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs
    file attributes $cfs -fileset bar
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs
    cookfs::Unmount $cfs
} -body {

    set fsid [cookfs::Mount $cfs $cfs -readonly -fileset bar]

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}

    $fsid aside $file2
    makeBinFile {bar_test3} "bar_test3" $cfs

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2 bar_test3}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
    assertEq [viewBinFile "bar_test3" $cfs] {bar_test3}

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2 bar_test3}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
    assertEq [viewBinFile "bar_test3" $cfs] {bar_test3}

} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.5.3.2 "Test fileset, aside, RO VFS, current fileset is preserved, add a file, add a fileset" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    set file2 [makeBinFile {} cookfs2.cfs]
    set fsid [cookfs::Mount $cfs $cfs -fileset foo]
    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs
    file attributes $cfs -fileset bar
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs
    cookfs::Unmount $cfs
} -body {

    set fsid [cookfs::Mount $cfs $cfs -readonly -fileset bar]

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}

    $fsid aside $file2
    makeBinFile {bar_test3} "bar_test3" $cfs

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2 bar_test3}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
    assertEq [viewBinFile "bar_test3" $cfs] {bar_test3}

    file attributes $cfs -fileset qux
    makeBinFile {qux_test1} "qux_test1" $cfs
    makeBinFile {qux_test2} "qux_test2" $cfs

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2 bar_test3}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
    assertEq [viewBinFile "bar_test3" $cfs] {bar_test3}

    file attributes $cfs -fileset qux
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {qux_test1 qux_test2}
    assertEq [viewBinFile "qux_test1" $cfs] {qux_test1}
    assertEq [viewBinFile "qux_test2" $cfs] {qux_test2}

} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.6.1 "Test fileset, open VFS with auto-fileset when platform is unknown" -constraints {
    enabledCVfs enabledCPkgconfig
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount $cfs $cfs -fileset foo]
    makeBinFile {foo_test1} "foo_test1" $cfs
    # Let's brake the VFS by setting its fileset mode to auto
    $fsid setmetadata "cookfs.fileset" "auto"
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly
} -cleanup {
    catch { cookfs::Unmount $cfs }
} -error [format {error when selecting a fileset: VFS does not have the required fileset "%s", it cannot be created due to read-only mode} "[::cookfs::pkgconfig get platform].tcl[join [split [info tclver] .] {}]"]

test cookfsVfs-24.1 "Test metadata attrib, default metadata keys" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    lsort [file attributes $cfs -metadata]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {cookfs.pagehash cookfs.pagesize cookfs.smallfilebuffer cookfs.smallfilesize}

test cookfsVfs-24.2 "Test metadata attrib, get single key" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata cookfs.pagehash
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {md5}

test cookfsVfs-24.3.1 "Test metadata attrib, get single key, empty key" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata {}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {a list of 1 or 2 elements is expected as an argument to the -metadata attribute}

test cookfsVfs-24.3.2 "Test metadata attrib, get single key, too many list elements" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata {1 2 3}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {a list of 1 or 2 elements is expected as an argument to the -metadata attribute}

test cookfsVfs-24.3.3 "Test metadata attrib, get single key, unknown key" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata foo
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {could not find metadata key "foo"}

test cookfsVfs-24.3.1 "Test metadata attrib, set single key" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata [list cookfs.pagehash crc32]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {crc32}

test cookfsVfs-24.3.2 "Test metadata attrib, set single key, custom key" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata [list foo bar]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {bar}

test cookfsVfs-24.4.1 "Test metadata attrib, set single key, test after reopening" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata [list cookfs.pagesize 123]
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
    file attributes $cfs -metadata cookfs.pagesize
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {123}

test cookfsVfs-24.4.2 "Test metadata attrib, set single key, custom key, test after reopening" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata [list foo bar]
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
    file attributes $cfs -metadata foo
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {bar}

test cookfsVfs-24.5 "Test metadata attrib, set single key, readonly VFS" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
} -body {
    file attributes $cfs -metadata [list cookfs.pagehash crc32]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {failed to set the metadata key: VFS is in readonly mode}

test cookfsVfs-25.1.1 "Test pages attrib, unknown argument" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -pages foo
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {bad pages information type "foo": must be pgindex, fsindex, length, or list}

test cookfsVfs-25.1.2 "Test pages attrib, negative argument" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -pages -1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {bad page index "-1" was specified, there are 0 pages in total}

test cookfsVfs-25.2.1 "Test pages attrib, newly created VFS" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [dict get [file attributes $cfs] -pages] 0
    assertEq [file attributes $cfs -pages] 0
    assertEq [file attributes $cfs -pages length] 0
    assertEq [file attributes $cfs -pages list] {}
    assertEq [file attributes $cfs -pages fsindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index fsindex}
    assertEq [file attributes $cfs -pages pgindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index pgindex}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-25.2.2 "Test pages attrib, newly created VFS, some data exists, but not saved yet" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -pagesize 100
    makeBinFile {X} "file" $cfs
} -body {
    assertEq [dict get [file attributes $cfs] -pages] 0
    assertEq [file attributes $cfs -pages] 0
    assertEq [file attributes $cfs -pages length] 0
    assertEq [file attributes $cfs -pages list] {}
    assertEq [file attributes $cfs -pages fsindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index fsindex}
    assertEq [file attributes $cfs -pages pgindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index pgindex}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-25.2.3 "Test pages attrib, newly created VFS, some data exists, 10 pages saved" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -pagesize 10 -smallfilebuffer 0 -compression none
    makeBinFile [randomData 100] "file" $cfs
} -body {
    assertEq [dict get [file attributes $cfs] -pages] 10
    assertEq [file attributes $cfs -pages] 10
    assertEq [file attributes $cfs -pages length] 10
    assertEq [llength [file attributes $cfs -pages list]] 10
    assertEq [file attributes $cfs -pages fsindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index fsindex}
    assertEq [file attributes $cfs -pages pgindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index pgindex}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-25.3.1 "Test pages attrib, previously created VFS, no pages" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
} -body {
    assertEq [dict get [file attributes $cfs] -pages] 0
    assertEq [file attributes $cfs -pages] 0
    assertEq [file attributes $cfs -pages length] 0
    assertEq [llength [file attributes $cfs -pages list]] 0
    # offset 15 is a stamp
    assertEq [file attributes $cfs -pages fsindex] {offset 15 uncompsize 129 compsize 129 encrypted 0 compression none index fsindex}
    assertEq [file attributes $cfs -pages pgindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index pgindex}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-25.3.2 "Test pages attrib, previously created VFS, 2 pages" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 10
    makeBinFile [randomData 20] "file" $cfs
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
} -body {
    assertEq [dict get [file attributes $cfs] -pages] 2
    assertEq [file attributes $cfs -pages] 2
    assertEq [file attributes $cfs -pages length] 2
    assertEq [file attributes $cfs -pages 0] {offset 0 uncompsize 10 compsize 10 encrypted 0 compression none index 0}
    assertEq [file attributes $cfs -pages 1] {offset 10 uncompsize 10 compsize 10 encrypted 0 compression none index 1}
    assertEq [file attributes $cfs -pages list] {{offset 0 uncompsize 10 compsize 10 encrypted 0 compression none index 0} {offset 10 uncompsize 10 compsize 10 encrypted 0 compression none index 1}}
    assertMatch [file attributes $cfs -pages pgindex] {offset 35 uncompsize * compsize * encrypted 0 compression none index pgindex}
    assertMatch [file attributes $cfs -pages fsindex] {offset * uncompsize * compsize * encrypted 0 compression none index fsindex}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-25.4 "Test pages attrib, compression and encryption" -constraints { enabledCVfs enabledTclCmds cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount $cfs $cfs -compression none -pagesize 10 -alwayscompress -smallfilebuffer 0]
    # page0 no compression, no encryption
    makeBinFile [randomData 10] "page1" $cfs
    $fsid password "foo"
    # page1 no compression, encryption
    makeBinFile [randomData 10] "page1" $cfs
    # page2 zlib default compression, encryption
    $fsid compression zlib
    makeBinFile [randomData 10] "page1" $cfs
    $fsid compression zlib:2
    $fsid password ""
    # page3 zlib level 2 compression, no encryption
    makeBinFile [randomData 10] "page1" $cfs
} -body {
    assertEq [file attributes $cfs -pages 0] {offset 0 uncompsize 10 compsize 10 encrypted 0 compression none index 0}
    assertMatch [file attributes $cfs -pages 1] {offset 10 uncompsize 10 compsize * encrypted 1 compression none index 1}
    assertMatch [file attributes $cfs -pages 2] {offset * uncompsize 10 compsize * encrypted 1 compression zlib index 2}
    assertMatch [file attributes $cfs -pages 3] {offset * uncompsize 10 compsize * encrypted 0 compression zlib:2 index 3}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.1 "Test attribute -metadata, cookfs.pagesize, exists by default" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertGe [file attributes $cfs -metadata cookfs.pagesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.2 "Test attribute -metadata, cookfs.pagesize, has expected value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 123
} -body {
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 123
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.3 "Test attribute -metadata, cookfs.pagesize, has expected value after remount" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 123
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 123
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.4 "Test attribute -metadata, cookfs.pagesize, has expected value after remount with a value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 123
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -pagesize 321
} -body {
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 321
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.5.1 "Test attribute -metadata, cookfs.pagesize, set wrong value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.pagesize foo]] foo
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    #assertGe [file attributes $cfs -metadata cookfs.pagesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.5.2 "Test attribute -metadata, cookfs.pagesize, set zero" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.pagesize 0]] 0
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertGe [file attributes $cfs -metadata cookfs.pagesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.5.3 "Test attribute -metadata, cookfs.pagesize, set negative" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.pagesize -2]] -2
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertGe [file attributes $cfs -metadata cookfs.pagesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.6 "Test attribute -metadata, cookfs.pagesize, the value is actual" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 10
} -body {
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 10
    assertEq [file attributes $cfs -pages] 0 "make sure we have no pages"
    makeBinFile [randomData 50] "test1" $cfs
    assertEq [file attributes $cfs -pages] 5 "make sure we have 5 pages"
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -pagesize 20
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 20
    makeBinFile [randomData 40] "test2" $cfs
    assertEq [file attributes $cfs -pages] 7 "make sure we have 7 pages"
    # set a value by -metadata
    assertEq [file attributes $cfs -metadata [list cookfs.pagesize 30]] 30
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 30
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 30
    makeBinFile [randomData 90] "test3" $cfs
    assertEq [file attributes $cfs -pages] 10 "make sure we have 10 pages"
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.1 "Test attribute -metadata, cookfs.smallfilesize, exists by default" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertGe [file attributes $cfs -metadata cookfs.smallfilesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.2 "Test attribute -metadata, cookfs.smallfilesize, has expected value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilesize 123
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 123
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.3 "Test attribute -metadata, cookfs.smallfilesize, has expected value after remount" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilesize 123
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 123
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.4 "Test attribute -metadata, cookfs.smallfilesize, has expected value after remount with a value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilesize 123
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -smallfilesize 321
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 321
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.5.1 "Test attribute -metadata, cookfs.smallfilesize, set wrong value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilesize foo]] foo
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertGe [file attributes $cfs -metadata cookfs.smallfilesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.5.2 "Test attribute -metadata, cookfs.smallfilesize, set zero" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilesize 0]] 0
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.5.3 "Test attribute -metadata, cookfs.smallfilesize, set negative" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilesize -2]] -2
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertGe [file attributes $cfs -metadata cookfs.smallfilesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.6 "Test attribute -metadata, cookfs.smallfilesize, the value is actual" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilesize 10 -smallfilebuffer 1000
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 10
    assertEq [file attributes $cfs -pages] 0 "make sure we have no pages"
    makeBinFile [randomData 5] "test1" $cfs
    makeBinFile [randomData 11] "test2" $cfs
    makeBinFile [randomData 5] "test3" $cfs
    makeBinFile [randomData 11] "test4" $cfs
    assertEq [file attributes $cfs -pages] 2 "make sure we have 2 pages"
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -smallfilesize 20
    assertEq [file attributes $cfs -pages] 3 "make sure we have 3 pages"
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 20
    makeBinFile [randomData 11] "test5" $cfs
    makeBinFile [randomData 21] "test6" $cfs
    assertEq [file attributes $cfs -pages] 4 "make sure we have 4 pages"
    # set a value by -metadata
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilesize 30]] 30
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 30
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    assertEq [file attributes $cfs -pages] 5 "make sure we have 5 pages"
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 30
    makeBinFile [randomData 11] "test7" $cfs
    makeBinFile [randomData 31] "test8" $cfs
    makeBinFile [randomData 31] "test9" $cfs
    assertEq [file attributes $cfs -pages] 7 "make sure we have 7 pages"
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    assertEq [file attributes $cfs -pages] 8 "make sure we have 8 pages"
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.1 "Test attribute -metadata, cookfs.smallfilebuffer, exists by default" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertGe [file attributes $cfs -metadata cookfs.smallfilebuffer] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.2 "Test attribute -metadata, cookfs.smallfilebuffer, has expected value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilebuffer 123
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 123
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.3 "Test attribute -metadata, cookfs.smallfilebuffer, has expected value after remount" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilebuffer 123
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 123
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.4 "Test attribute -metadata, cookfs.smallfilebuffer, has expected value after remount with a value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilebuffer 123
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -smallfilebuffer 321
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 321
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.5.1 "Test attribute -metadata, cookfs.smallfilebuffer, set wrong value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilebuffer foo]] foo
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertGe [file attributes $cfs -metadata cookfs.smallfilebuffer] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.5.2 "Test attribute -metadata, cookfs.smallfilebuffer, set zero" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilebuffer 0]] 0
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.5.3 "Test attribute -metadata, cookfs.smallfilebuffer, set negative" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilebuffer -2]] -2
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertGe [file attributes $cfs -metadata cookfs.smallfilebuffer] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.6 "Test attribute -metadata, cookfs.smallfilebuffer, the value is actual" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilesize 9 -smallfilebuffer 10 -pagesize 1000
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 10
    assertEq [file attributes $cfs -pages] 0 "make sure we have no pages"
    makeBinFile [randomData 5] "test1" $cfs
    makeBinFile [randomData 5] "test2" $cfs
    makeBinFile [randomData 4] "test3" $cfs
    makeBinFile [randomData 5] "test4" $cfs
    assertEq [file attributes $cfs -pages] 1 "make sure we have 1 page"
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -smallfilebuffer 20
    assertEq [file attributes $cfs -pages] 2 "make sure we have 2 pages"
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 20
    makeBinFile [randomData 8] "test5.1" $cfs
    makeBinFile [randomData 8] "test5.2" $cfs
    makeBinFile [randomData 8] "test5.3" $cfs
    assertEq [file attributes $cfs -pages] 3 "make sure we have 3 pages"
    # set a value by -metadata
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilebuffer 30]] 30
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 30
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    assertEq [file attributes $cfs -pages] 4 "make sure we have 4 pages"
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 30
    makeBinFile [randomData 8] "test7" $cfs
    makeBinFile [randomData 8] "test8" $cfs
    makeBinFile [randomData 8] "test9" $cfs
    makeBinFile [randomData 8] "test9.1" $cfs
    makeBinFile [randomData 8] "test9.2" $cfs
    assertEq [file attributes $cfs -pages] 5 "make sure we have 5 pages"
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    assertEq [file attributes $cfs -pages] 6 "make sure we have 6 pages"
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-29.1.1 "Test attribute -archive, get, existing file" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -archive] $cfs
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-29.1.2 "Test attribute -archive, get, writetomemory VFS" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -writetomemory
} -body {
    assertEq [file attributes $cfs -archive] ""
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-29.1.3 "Test attribute -archive, get, mounted as volume" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    set vol "test://"
    cookfs::Mount $cfs $vol -compression none -volume
} -body {
    assertEq [file attributes [string range $vol 0 end] -archive] $cfs
} -cleanup {
    cookfs::Unmount $vol
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-29.2 "Test attribute -archive, set" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attributes $cfs -archive foo
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-archive" is read-only}

test cookfsVfs-30.1.1 "Test attribute -password, get, default unencrypted VFS" -constraints {
    enabledCVfs cookfsCrypto
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attributes $cfs -password
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-30.1.2 "Test attribute -password, get, default encrypted VFS" -constraints {
    enabledCVfs cookfsCrypto
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptlevel 0
} -body {
    file attributes $cfs -password
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 1

test cookfsVfs-30.1.3 "Test attribute -password, get, default writetomemory VFS" -constraints {
    enabledCVfs cookfsCrypto
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -writetomemory
} -body {
    file attributes $cfs -password
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-30.2.1 "Test attribute -password, set, default unencrypted VFS" -constraints {
    enabledCVfs cookfsCrypto
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -encryptlevel 0
} -body {
    file attributes $cfs -password foo
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 1

test cookfsVfs-30.2.2 "Test attribute -password, set, default encrypted VFS" -constraints {
    enabledCVfs cookfsCrypto
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -encryptlevel 0 -password foo
} -body {
    file attributes $cfs -password ""
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-30.2.3 "Test attribute -password, set, default unencrypted VFS, verify" -constraints {
    enabledCVfs cookfsCrypto
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -encryptlevel 0
    variable data
} -body {
    makeBinFile {THIS_IS_1_UNENCRYPTED} "file1" $cfs
    assertEq [file attributes $cfs -password] 0
    assertEq [file attributes $cfs -password foo] 1
    assertEq [file attributes $cfs -password] 1
    makeBinFile {THIS_IS_ENCRYPTED} "file2" $cfs
    assertEq [file attributes $cfs -password ""] 0
    assertEq [file attributes $cfs -password] 0
    makeBinFile {THIS_IS_2_UNENCRYPTED} "file3" $cfs
    cookfs::Unmount $cfs
    set data [viewBinFile $cfs]
    assertContain $data "THIS_IS_1_UNENCRYPTED" "file1 should be unencrypted"
    assertNotContain $data "THIS_IS_ENCRYPTED" "test2 should be encrypted"
    assertContain $data "THIS_IS_2_UNENCRYPTED" "file3 should be unencrypted"
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-30.2.4 "Test attribute -password, set, default encrypted VFS, verify" -constraints {
    enabledCVfs cookfsCrypto
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -encryptlevel 0 -password foo
    variable data
} -body {
    makeBinFile {THIS_IS_1_UNENCRYPTED} "file1" $cfs
    assertEq [file attributes $cfs -password] 1
    assertEq [file attributes $cfs -password ""] 0
    assertEq [file attributes $cfs -password] 0
    makeBinFile {THIS_IS_ENCRYPTED} "file2" $cfs
    assertEq [file attributes $cfs -password "foo"] 1
    assertEq [file attributes $cfs -password] 1
    makeBinFile {THIS_IS_2_UNENCRYPTED} "file3" $cfs
    cookfs::Unmount $cfs
    set data [viewBinFile $cfs]
    assertNotContain $data "THIS_IS_1_UNENCRYPTED" "file1 should be unencrypted"
    assertContain $data "THIS_IS_ENCRYPTED" "test2 should be encrypted"
    assertNotContain $data "THIS_IS_2_UNENCRYPTED" "file3 should be unencrypted"
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-31.1.1 "Test attribute -readonly, get, RW VFS" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -readonly
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-31.1.2 "Test attribute -readonly, get, RO VFS" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
} -body {
    file attribute $cfs -readonly
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 1

test cookfsVfs-31.2.1 "Test attribute -readonly, set" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -readonly 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-readonly" is read-only}

test cookfsVfs-32.1.1 "Test attribute -readonly, get, writetomemory disabled" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -writetomemory
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-32.1.2 "Test attribute -readonly, get, writetomemory enabled" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -writetomemory
} -body {
    file attribute $cfs -writetomemory
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 1

test cookfsVfs-32.2.1.1 "Test attribute -readonly, set true, writetomemory disabled" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
} -body {
    assertEq [file attribute $cfs -writetomemory] 0
    assertEq [file attribute $cfs -readonly] 1
    assertEq [file attribute $cfs -writetomemory 1] 1
    assertEq [file attribute $cfs -writetomemory] 1
    assertEq [file attribute $cfs -readonly] 0
    makeBinFile "TEST" "test" $cfs
    assertEq [viewBinFile "test" $cfs] "TEST"
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-32.2.1.2 "Test attribute -readonly, set false, writetomemory disabled" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
} -body {
    assertEq [file attribute $cfs -writetomemory] 0
    assertEq [file attribute $cfs -writetomemory 0] 0
    assertEq [file attribute $cfs -writetomemory] 0
    makeBinFile {TEST} "test" $cfs
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -match glob -error {couldn't open "*": read-only file system}

test cookfsVfs-32.2.2.1 "Test attribute -readonly, set true, writetomemory enabled" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -writetomemory
} -body {
    assertEq [file attribute $cfs -writetomemory] 1
    assertEq [file attribute $cfs -readonly] 0
    assertEq [file attribute $cfs -writetomemory 1] 1
    assertEq [file attribute $cfs -writetomemory] 1
    assertEq [file attribute $cfs -readonly] 0
    makeBinFile {TEST} "test" $cfs
    assertEq [viewBinFile "test" $cfs] "TEST"
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-32.2.2.2 "Test attribute -readonly, set false, writetomemory enabled" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -writetomemory
} -body {
    file attribute $cfs -writetomemory 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {unable to disable writetomemory mode when it is already enabled}

test cookfsVfs-32.2.3 "Test attribute -readonly, set true and false" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
} -body {
    assertEq [file attribute $cfs -writetomemory] 0
    assertEq [file attribute $cfs -readonly] 1
    assertEq [file attribute $cfs -writetomemory 1] 1
    assertEq [file attribute $cfs -writetomemory] 1
    assertEq [file attribute $cfs -readonly] 0
    makeBinFile {TEST} "test" $cfs
    assertEq [viewBinFile "test" $cfs] "TEST"
    file attribute $cfs -writetomemory 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {unable to disable writetomemory mode when it is already enabled}

test cookfsVfs-33.1.1 "Test attribute -smallfilebuffersize, get, newly created VFS" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -smallfilebuffersize
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-33.1.2 "Test attribute -smallfilebuffersize, get, some data exists" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilesize 64 -smallfilebuffer 1024 -pagesize 1024
} -body {
    makeBinFile {TEST1} "test1" $cfs
    makeBinFile {TESTA2} "test2" $cfs
    file attribute $cfs -smallfilebuffersize
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 11

test cookfsVfs-33.2.1 "Test attribute -smallfilebuffersize, set" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -smallfilebuffersize 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-smallfilebuffersize" is read-only}

test cookfsVfs-34.1.1 "Test attribute -cachesize, get, check default" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertGt [file attribute $cfs -cachesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-34.1.2 "Test attribute -cachesize, get, check expected value 11" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagecachesize 11
} -body {
    file attribute $cfs -cachesize
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 11

test cookfsVfs-34.2.1 "Test attribute -cachesize, set, wrong value" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -cachesize a
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {expected integer but got "a"}

test cookfsVfs-34.2.2 "Test attribute -cachesize, set, good value" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagecachesize 123
} -body {
    assertEq [file attribute $cfs -cachesize] 123
    assertEq [file attribute $cfs -cachesize 12] 12
    assertEq [file attribute $cfs -cachesize] 12
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-35.1.1 "Test attribute -volume, get, value false" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -volume
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-35.1.2 "Test attribute -volume, get, value true" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -volume
} -body {
    file attribute $cfs -volume
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 1

test cookfsVfs-35.2.1 "Test attribute -volume, set" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -volume 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-volume" is read-only}

test cookfsVfs-36.1.1 "Test attribute -shared, get, value false" -constraints { enabledCVfs threaded } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -shared
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-36.1.2 "Test attribute -shared, get, value true" -constraints { enabledCVfs threaded } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -shared
} -body {
    file attribute $cfs -shared
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 1

test cookfsVfs-36.2.1 "Test attribute -shared, set" -constraints { enabledCVfs threaded } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -shared 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-shared" is read-only}

test cookfsVfs-37.1.1 "Test attribute -compression, get, none value" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -compression
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result none

test cookfsVfs-37.1.2 "Test attribute -compression, get, zlib value" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression zlib
} -body {
    file attribute $cfs -compression
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result zlib

test cookfsVfs-37.1.3 "Test attribute -compression, get, writetomemory VFS" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -writetomemory
} -body {
    file attribute $cfs -compression
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result none

test cookfsVfs-37.2.1.1 "Test attribute -compression, set, writetomemory VFS" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -writetomemory
} -body {
    file attribute $cfs -compression none
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {unable to set compression on a writetomemory VFS}

test cookfsVfs-37.2.1.2 "Test attribute -compression, set, wrong value" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -compression 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {bad compression "1": must be none, zlib, lzma, or custom}

test cookfsVfs-37.2.1.3 "Test attribute -compression, set, wrong level" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -compression none:none
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {expected integer but got "none"}

test cookfsVfs-37.2.1.4 "Test attribute -compression, set, RO VFS" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
} -body {
    file attribute $cfs -compression none
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {unable to set compression on a readonly VFS}

test cookfsVfs-37.2.2 "Test attribute -compression, set, verify values" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilebuffer 0 -alwayscompress
} -body {
    assertEq [file attributes $cfs -pages] 0 "make sure there are no pages"
    assertEq [file attribute $cfs -compression "zlib:2"] "zlib:2"
    assertEq [file attribute $cfs -compression] "zlib:2"
    makeBinFile "TEST1" "test1" $cfs
    assertEq [file attribute $cfs -compression "none"] "none"
    assertEq [file attribute $cfs -compression] "none"
    makeBinFile "TEST2" "test2" $cfs
    assertEq [file attribute $cfs -compression "zlib"] "zlib"
    assertEq [file attribute $cfs -compression] "zlib"
    makeBinFile "TEST3" "test3" $cfs
    assertEq [file attributes $cfs -pages] 3 "make sure there are 3 pages"
    # verify
    assertEq [dict get [file attributes $cfs -pages 0] compression] "zlib:2"
    assertEq [dict get [file attributes $cfs -pages 1] compression] "none"
    assertEq [dict get [file attributes $cfs -pages 2] compression] "zlib"
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-38.1.1 "Test attribute -encryptkey, get, value false (default)" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -encryptkey
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-38.1.2 "Test attribute -encryptkey, get, value true" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -encryptkey
} -body {
    file attribute $cfs -encryptkey
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 1

test cookfsVfs-38.1.3 "Test attribute -encryptkey, get, writetomemory VFS" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -writetomemory
} -body {
    file attribute $cfs -encryptkey
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-38.2.1 "Test attribute -encryptkey, set" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -encryptkey 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-encryptkey" is read-only}

test cookfsVfs-39.1.1 "Test attribute -encryptlevel, get, default value" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertGt [file attribute $cfs -encryptlevel] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-39.1.2 "Test attribute -encryptlevel, get, known value" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -encryptlevel 2
} -body {
    file attribute $cfs -encryptlevel
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 2

test cookfsVfs-39.1.3 "Test attribute -encryptlevel, get, writetomemory VFS" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -writetomemory
} -body {
    file attribute $cfs -encryptlevel
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-39.2.1 "Test attribute -encryptlevel, set" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -encryptlevel 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-encryptlevel" is read-only}

test cookfsVfs-40.1.1 "Test attribute -parts, get, newly created VFS" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -parts
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {headsize -1 datasize -1 tailsize -1}

test cookfsVfs-40.1.2 "Test attribute -parts, get, newly created VFS in writetomemory mode" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -writetomemory
} -body {
    file attribute $cfs -parts
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {headsize -1 datasize -1 tailsize -1}

test cookfsVfs-40.2.1.1 "Test attribute -parts, get, empty VFS, RW mode" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    variable val
} -body {
    set val [file attribute $cfs -parts]
    cookfs::Unmount $cfs
    assertEq $val [dict create \
        headsize 0 \
        datasize [file size $cfs] \
        tailsize 0]
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.2.1.2 "Test attribute -parts, get, empty VFS, RO mode" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
    variable val
} -body {
    set val [file attribute $cfs -parts]
    cookfs::Unmount $cfs
    assertEq $val [dict create \
        headsize 0 \
        datasize [file size $cfs] \
        tailsize 0]
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.2.2.1 "Test attribute -parts, get, empty VFS, file encryption" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptlevel 0
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -password foo
    variable val
} -body {
    set val [file attribute $cfs -parts]
    cookfs::Unmount $cfs
    assertEq $val [dict create \
        headsize 0 \
        datasize [file size $cfs] \
        tailsize 0]
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.2.2.2 "Test attribute -parts, get, empty VFS, key encryption" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptlevel 0 -encryptkey
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -password foo
    variable val
} -body {
    set val [file attribute $cfs -parts]
    cookfs::Unmount $cfs
    assertEq $val [dict create \
        headsize 0 \
        datasize [file size $cfs] \
        tailsize 0]
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.3.1.1 "Test attribute -parts, get, head+tail, RW mode" -constraints { enabledCVfs } -setup {
    set head {HEADAA}
    set tail [string repeat X 34]
    set cfs [makeBinFile $head pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    set filesize [file size $cfs]
    cookfs::Mount $cfs $cfs
    variable val
} -body {
    set val [file attribute $cfs -parts]
    cookfs::Unmount $cfs
    assertEq $val [dict create \
        headsize [string length $head] \
        datasize [expr { $filesize - [string length $head] - [string length $tail] }] \
        tailsize [string length $tail]]
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.3.1.2 "Test attribute -parts, get, head+tail, RO mode" -constraints { enabledCVfs } -setup {
    set head {HEADAA}
    set tail [string repeat X 34]
    set cfs [makeBinFile $head pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    makeBinFile {DATAFILE} "test" $cfs
    cookfs::Unmount $cfs
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    cookfs::Mount $cfs $cfs -readonly
    variable val
} -body {
    set val [file attribute $cfs -parts]
    cookfs::Unmount $cfs
    assertEq $val [dict create \
        headsize [string length $head] \
        datasize [expr { [file size $cfs] - [string length $head] - [string length $tail] }] \
        tailsize [string length $tail]]
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.3.2.1 "Test attribute -parts, get, head+tail, file encryption" -constraints { enabledCVfs cookfsCrypto } -setup {
    set head {HEADAA}
    set tail [string repeat X 34]
    set cfs [makeBinFile $head pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptlevel 0
    makeBinFile {DATAFILE} "test" $cfs
    cookfs::Unmount $cfs
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    set filesize [file size $cfs]
    cookfs::Mount $cfs $cfs -password foo
    variable val
} -body {
    set val [file attribute $cfs -parts]
    cookfs::Unmount $cfs
    assertEq $val [dict create \
        headsize [string length $head] \
        datasize [expr { $filesize - [string length $head] - [string length $tail] }] \
        tailsize [string length $tail]]
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.3.2.2 "Test attribute -parts, get, head+tail, key encryption" -constraints { enabledCVfs cookfsCrypto } -setup {
    set head {HEADAA}
    set tail [string repeat X 34]
    set cfs [makeBinFile $head pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptlevel 0 -encryptkey
    makeBinFile {DATAFILE} "test" $cfs
    cookfs::Unmount $cfs
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    set filesize [file size $cfs]
    cookfs::Mount $cfs $cfs -password foo
    variable val
} -body {
    set val [file attribute $cfs -parts]
    cookfs::Unmount $cfs
    assertEq $val [dict create \
        headsize [string length $head] \
        datasize [expr { $filesize - [string length $head] - [string length $tail] }] \
        tailsize [string length $tail]]
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.4.1.1 "Test attribute -parts, set, writetomemory VFS" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -writetomemory
} -body {
    file attribute $cfs -parts head
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {unable to get archive parts from a writetomemory VFS}

test cookfsVfs-40.4.1.2 "Test attribute -parts, set, not on disk" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    file attribute $cfs -parts head
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {the archive has not yet been saved to disk}

test cookfsVfs-40.4.1.4 "Test attribute -parts, set, empty argument" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
} -body {
    file attribute $cfs -parts ""
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {a list of 1 or 2 elements is expected as an argument to the -parts attribute}

test cookfsVfs-40.4.1.5 "Test attribute -parts, set, too many list elements" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
} -body {
    file attribute $cfs -parts {1 2 3}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {a list of 1 or 2 elements is expected as an argument to the -parts attribute}

test cookfsVfs-40.4.1.6 "Test attribute -parts, set, wrong argument" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
} -body {
    file attribute $cfs -parts "foo"
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {bad archive part type "foo": must be head, data, or tail}

test cookfsVfs-40.5.1.1 "Test attribute -parts, set, empty VFS, RW mode" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    set data [viewBinFile $cfs]
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [file attribute $cfs -parts head] ""
    assertEq [file attribute $cfs -parts data] $data
    assertEq [file attribute $cfs -parts tail] ""
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.5.1.2 "Test attribute -parts, set, empty VFS, RO mode" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    set data [viewBinFile $cfs]
    cookfs::Mount $cfs $cfs -readonly
} -body {
    assertEq [file attribute $cfs -parts head] ""
    assertEq [file attribute $cfs -parts data] $data
    assertEq [file attribute $cfs -parts tail] ""
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.5.2.1 "Test attribute -parts, set, empty VFS, file encryption" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptlevel 0
    cookfs::Unmount $cfs
    set data [viewBinFile $cfs]
    cookfs::Mount $cfs $cfs -password foo
} -body {
    assertEq [file attribute $cfs -parts head] ""
    assertEq [file attribute $cfs -parts data] $data
    assertEq [file attribute $cfs -parts tail] ""
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.5.2.2 "Test attribute -parts, set, empty VFS, key encryption" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptkey -encryptlevel 0
    cookfs::Unmount $cfs
    set data [viewBinFile $cfs]
    cookfs::Mount $cfs $cfs -password foo
} -body {
    assertEq [file attribute $cfs -parts head] ""
    assertEq [file attribute $cfs -parts data] $data
    assertEq [file attribute $cfs -parts tail] ""
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.6.1.1 "Test attribute -parts, set, head+tail, RW mode" -constraints { enabledCVfs } -setup {
    set head {HEADAA}
    set tail [string repeat X 34]
    set cfs [makeBinFile $head pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    makeBinFile {DATAFILE} "test" $cfs
    cookfs::Unmount $cfs
    set data [string range [viewBinFile $cfs] [string length $head] end]
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [file attribute $cfs -parts head] $head
    assertEq [file attribute $cfs -parts data] $data
    assertEq [file attribute $cfs -parts tail] $tail
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.6.1.2 "Test attribute -parts, set, head+tail, RO mode" -constraints { enabledCVfs } -setup {
    set head {HEADAA}
    set tail [string repeat X 34]
    set cfs [makeBinFile $head pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    makeBinFile {DATAFILE} "test" $cfs
    cookfs::Unmount $cfs
    set data [string range [viewBinFile $cfs] [string length $head] end]
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    cookfs::Mount $cfs $cfs -readonly
} -body {
    assertEq [file attribute $cfs -parts head] $head
    assertEq [file attribute $cfs -parts data] $data
    assertEq [file attribute $cfs -parts tail] $tail
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.6.2.1 "Test attribute -parts, set, head+tail, file encryption" -constraints { enabledCVfs cookfsCrypto } -setup {
    set head {HEADAA}
    set tail [string repeat X 34]
    set cfs [makeBinFile $head pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptlevel 0
    makeBinFile {DATAFILE} "test" $cfs
    cookfs::Unmount $cfs
    set data [string range [viewBinFile $cfs] [string length $head] end]
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    cookfs::Mount $cfs $cfs -password foo
} -body {
    assertEq [file attribute $cfs -parts head] $head
    assertEq [file attribute $cfs -parts data] $data
    assertEq [file attribute $cfs -parts tail] $tail
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.6.2.2 "Test attribute -parts, set, head+tail, key encryption" -constraints { enabledCVfs cookfsCrypto } -setup {
    set head {HEADAA}
    set tail [string repeat X 34]
    set cfs [makeBinFile $head pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptlevel 0 -encryptkey
    makeBinFile {DATAFILE} "test" $cfs
    cookfs::Unmount $cfs
    set data [string range [viewBinFile $cfs] [string length $head] end]
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    cookfs::Mount $cfs $cfs -password foo
} -body {
    assertEq [file attribute $cfs -parts head] $head
    assertEq [file attribute $cfs -parts data] $data
    assertEq [file attribute $cfs -parts tail] $tail
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.7.1.1 "Test attribute -parts, set to chan, empty VFS, RW mode" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    set data [viewBinFile $cfs]
    cookfs::Mount $cfs $cfs
    variable fd
} -body {
    assertEq [file attribute $cfs -parts [list head [set fd [open [makeBinFile {} head] "wb"]]]] 0
    close $fd
    assertEq [file attribute $cfs -parts [list data [set fd [open [makeBinFile {} data] "wb"]]]] [string length $data]
    close $fd
    assertEq [file attribute $cfs -parts [list tail [set fd [open [makeBinFile {} tail] "wb"]]]] 0
    close $fd
    assertEq [viewBinFile head] ""
    assertEq [viewBinFile data] $data
    assertEq [viewBinFile tail] ""
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.7.1.2 "Test attribute -parts, set to chan, empty VFS, RO mode" -constraints { enabledCVfs } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    set data [viewBinFile $cfs]
    cookfs::Mount $cfs $cfs -readonly
    variable fd
} -body {
    assertEq [file attribute $cfs -parts [list head [set fd [open [makeBinFile {} head] "wb"]]]] 0
    close $fd
    assertEq [file attribute $cfs -parts [list data [set fd [open [makeBinFile {} data] "wb"]]]] [string length $data]
    close $fd
    assertEq [file attribute $cfs -parts [list tail [set fd [open [makeBinFile {} tail] "wb"]]]] 0
    close $fd
    assertEq [viewBinFile head] ""
    assertEq [viewBinFile data] $data
    assertEq [viewBinFile tail] ""
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.7.2.1 "Test attribute -parts, set to chan, empty VFS, file encryption" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptlevel 0
    cookfs::Unmount $cfs
    set data [viewBinFile $cfs]
    cookfs::Mount $cfs $cfs -password foo
    variable fd
} -body {
    assertEq [file attribute $cfs -parts [list head [set fd [open [makeBinFile {} head] "wb"]]]] 0
    close $fd
    assertEq [file attribute $cfs -parts [list data [set fd [open [makeBinFile {} data] "wb"]]]] [string length $data]
    close $fd
    assertEq [file attribute $cfs -parts [list tail [set fd [open [makeBinFile {} tail] "wb"]]]] 0
    close $fd
    assertEq [viewBinFile head] ""
    assertEq [viewBinFile data] $data
    assertEq [viewBinFile tail] ""
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.7.2.2 "Test attribute -parts, set to chan, empty VFS, key encryption" -constraints { enabledCVfs cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptkey -encryptlevel 0
    cookfs::Unmount $cfs
    set data [viewBinFile $cfs]
    cookfs::Mount $cfs $cfs -password foo
    variable fd
} -body {
    assertEq [file attribute $cfs -parts [list head [set fd [open [makeBinFile {} head] "wb"]]]] 0
    close $fd
    assertEq [file attribute $cfs -parts [list data [set fd [open [makeBinFile {} data] "wb"]]]] [string length $data]
    close $fd
    assertEq [file attribute $cfs -parts [list tail [set fd [open [makeBinFile {} tail] "wb"]]]] 0
    close $fd
    assertEq [viewBinFile head] ""
    assertEq [viewBinFile data] $data
    assertEq [viewBinFile tail] ""
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.8.1.1 "Test attribute -parts, set to chan, head+tail, RW mode" -constraints { enabledCVfs } -setup {
    set head [string repeat "ABC" 123456]
    set tail [string repeat X 3456]
    set cfs [makeBinFile $head pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    makeBinFile [string repeat {DATAFILE} 10000] "test" $cfs
    cookfs::Unmount $cfs
    set data [string range [viewBinFile $cfs] [string length $head] end]
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [file attribute $cfs -parts [list head [set fp [open [makeBinFile {} head] "wb"]]]] [string length $head]
    close $fp
    assertEq [file attribute $cfs -parts [list data [set fp [open [makeBinFile {} data] "wb"]]]] [string length $data]
    close $fp
    assertEq [file attribute $cfs -parts [list tail [set fp [open [makeBinFile {} tail] "wb"]]]] [string length $tail]
    close $fp
    assertEq [viewBinFile head] $head
    assertEq [viewBinFile data] $data
    assertEq [viewBinFile tail] $tail
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.8.1.2 "Test attribute -parts, set to chan, head+tail, RO mode" -constraints { enabledCVfs } -setup {
    set head [string repeat "ABC" 123456]
    set tail [string repeat X 3456]
    set cfs [makeBinFile $head pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    makeBinFile [string repeat {DATAFILE} 10000] "test" $cfs
    cookfs::Unmount $cfs
    set data [string range [viewBinFile $cfs] [string length $head] end]
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    cookfs::Mount $cfs $cfs -readonly
} -body {
    assertEq [file attribute $cfs -parts [list head [set fp [open [makeBinFile {} head] "wb"]]]] [string length $head]
    close $fp
    assertEq [file attribute $cfs -parts [list data [set fp [open [makeBinFile {} data] "wb"]]]] [string length $data]
    close $fp
    assertEq [file attribute $cfs -parts [list tail [set fp [open [makeBinFile {} tail] "wb"]]]] [string length $tail]
    close $fp
    assertEq [viewBinFile head] $head
    assertEq [viewBinFile data] $data
    assertEq [viewBinFile tail] $tail
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.8.2.1 "Test attribute -parts, set to chan, head+tail, file encryption" -constraints { enabledCVfs cookfsCrypto } -setup {
    set head [string repeat "ABC" 123456]
    set tail [string repeat X 3456]
    set cfs [makeBinFile $head pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptlevel 0
    makeBinFile [string repeat {DATAFILE} 10000] "test" $cfs
    cookfs::Unmount $cfs
    set data [string range [viewBinFile $cfs] [string length $head] end]
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    cookfs::Mount $cfs $cfs -password foo
} -body {
    assertEq [file attribute $cfs -parts [list head [set fp [open [makeBinFile {} head] "wb"]]]] [string length $head]
    close $fp
    assertEq [file attribute $cfs -parts [list data [set fp [open [makeBinFile {} data] "wb"]]]] [string length $data]
    close $fp
    assertEq [file attribute $cfs -parts [list tail [set fp [open [makeBinFile {} tail] "wb"]]]] [string length $tail]
    close $fp
    assertEq [viewBinFile head] $head
    assertEq [viewBinFile data] $data
    assertEq [viewBinFile tail] $tail
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.8.2.2 "Test attribute -parts, set to chan, head+tail, key encryption" -constraints { enabledCVfs cookfsCrypto } -setup {
    set head [string repeat "ABC" 123456]
    set tail [string repeat X 3456]
    set cfs [makeBinFile $head pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptlevel 0 -encryptkey
    makeBinFile [string repeat {DATAFILE} 10000] "test" $cfs
    cookfs::Unmount $cfs
    set data [string range [viewBinFile $cfs] [string length $head] end]
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    cookfs::Mount $cfs $cfs -password foo
} -body {
    assertEq [file attribute $cfs -parts [list head [set fp [open [makeBinFile {} head] "wb"]]]] [string length $head]
    close $fp
    assertEq [file attribute $cfs -parts [list data [set fp [open [makeBinFile {} data] "wb"]]]] [string length $data]
    close $fp
    assertEq [file attribute $cfs -parts [list tail [set fp [open [makeBinFile {} tail] "wb"]]]] [string length $tail]
    close $fp
    assertEq [viewBinFile head] $head
    assertEq [viewBinFile data] $data
    assertEq [viewBinFile tail] $tail
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.8.3.1 "Test attribute -parts, set to chan, rebuild archive" -constraints { enabledCVfs } -setup {
    set head [string repeat "ABC" 123456]
    set tail [string repeat X 3456]
    set cfs [makeBinFile $head pages.cfs]
    set cfs2 [makeBinFile {} pages2.cfs]
    cookfs::Mount $cfs $cfs -compression none
    makeBinFile [string repeat {DATAFILE} 10000] "test" $cfs
    cookfs::Unmount $cfs
    set data [string range [viewBinFile $cfs] [string length $head] end]
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    cookfs::Mount $cfs $cfs -readonly
} -body {
    set fp [open $cfs2 ab]
    file attribute $cfs -parts [list head $fp]
    file attribute $cfs -parts [list data $fp]
    file attribute $cfs -parts [list tail $fp]
    close $fp
    cookfs::Unmount $cfs
    assertEq [viewBinFile $cfs] [viewBinFile $cfs2]
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-40.8.3.2 "Test attribute -parts, set to chan, extract only data part" -constraints { enabledCVfs cookfsCrypto } -setup {
    set head [string repeat "ABC" 123456]
    set tail [string repeat X 3456]
    set data [string repeat {DATAFILE} 10000]
    set cfs [makeBinFile $head pages.cfs]
    set cfs2 [makeBinFile {} pages2.cfs]
    cookfs::Mount $cfs $cfs -compression none -password foo -encryptlevel 0 -encryptkey
    makeBinFile $data "test" $cfs
    cookfs::Unmount $cfs
    puts -nonewline [set fp [open $cfs "ab"]] $tail; close $fp
    cookfs::Mount $cfs $cfs -readonly -password foo
} -body {
    set fp [open $cfs2 ab]
    file attribute $cfs -parts [list data $fp]
    close $fp
    cookfs::Unmount $cfs
    cookfs::Mount $cfs2 $cfs2 -readonly -password foo
    assertEq [viewBinFile test $cfs2] $data
} -cleanup {
    catch { cookfs::Unmount $cfs }
    cookfs::Unmount $cfs2
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-41.1.1 "Test attribute -mount, get, normal mount" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    set dir [makeDirectory dir $cfs]
    set file [makeFile {TEST} "testfile" $dir]
} -body {
    assertEq [file attributes $file -mount] $cfs
    assertEq [file attributes $dir -mount] $cfs
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-41.1.2 "Test attribute -mount, get, volume mount" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    set volume "test://"
    cookfs::Mount $cfs $volume -compression none -volume
    set dir [makeDirectory dir $volume]
    set file [makeFile {TEST} "testfile" $dir]
} -body {
    assertEq [file attributes $file -mount] $volume
    assertEq [file attributes $dir -mount] $volume
} -cleanup {
    cookfs::Unmount $volume
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-41.2.1 "Test attribute -mount, set" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    set dir [makeDirectory dir $cfs]
    set file [makeFile {TEST} "testfile" $dir]
} -body {
    file attributes $file -mount 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-mount" is read-only}

test cookfsVfs-42.1 "Test attribute -pending, get" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 1024 -smallfilesize 100 -smallfilebuffer 1024
    # big file, will be stored to pages
    set file1 [makeBinFile [string repeat {TEST} 500] "testfile1" $cfs]
    # small file, will be in smallfilebuffer
    set file2 [makeBinFile {TEST} "testfile2" $cfs]
} -body {
    assertEq [file attributes $file1 -pending] 0
    assertEq [file attributes $file2 -pending] 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-42.2 "Test attribute -pending, set" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 1024 -smallfilesize 100 -smallfilebuffer 1024
    # big file, will be stored to pages
    set file1 [makeBinFile [string repeat {TEST} 500] "testfile1" $cfs]
} -body {
    file attributes $file1 -pending 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-pending" is read-only}

test cookfsVfs-43.1 "Test attribute -uncompsize, get" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 1024 -smallfilesize 100 -smallfilebuffer 1024
    # big file, will be stored to pages
    set data1 [string repeat {TEST} 500]
    set file1 [makeBinFile $data1 "testfile1" $cfs]
    # small file, will be in smallfilebuffer
    set data2 {TEST}
    set file2 [makeBinFile $data2 "testfile2" $cfs]
} -body {
    assertEq [file attributes $file1 -uncompsize] [string length $data1]
    assertEq [file attributes $file2 -uncompsize] [string length $data2]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-43.2 "Test attribute -uncompsize, set" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 1024 -smallfilesize 100 -smallfilebuffer 1024
    # big file, will be stored to pages
    set file1 [makeBinFile [string repeat {TEST} 500] "testfile1" $cfs]
} -body {
    file attributes $file1 -uncompsize 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-uncompsize" is read-only}

test cookfsVfs-44.1.1 "Test attribute -compsize, get, compression none" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 2048 -smallfilesize 1024 -smallfilebuffer 2048
    # one file for 1 page
    set file1 [makeBinFile [string repeat X 2048] file1 $cfs]
    # many files in 1 page
    set file21 [makeBinFile [string repeat X 512] file21 $cfs]
    set file22 [makeBinFile [string repeat X 1] file22 $cfs]
    set file23 [makeBinFile [string repeat X 131] file23 $cfs]
    # flush pages by changing compression
    file attribute $cfs -compression none
    # one big file for many pages, some pages are duplicated
    set file3 [makeBinFile [string repeat X 7001] file3 $cfs]
    # one big file for many different pages
    set file4 [makeBinFile [string repeat {ABC} 1368] file4 $cfs]
} -body {
    assertEq [file attributes $file1 -compsize] 2048
    assertEq [file attributes $file21 -compsize] 512
    assertEq [file attributes $file22 -compsize] 1
    assertEq [file attributes $file23 -compsize] 131
    assertEq [file attributes $file3 -compsize] 7001
    assertEq [file attributes $file4 -compsize] 4104
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-44.1.2 "Test attribute -compsize, get, compression zlib" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression zlib -pagesize 2048 -smallfilesize 1024 -smallfilebuffer 2048 -alwayscompress
    # one file for 1 page
    set file1 [makeBinFile [string repeat X 2048] file1 $cfs]
    # many files in 1 page
    set file21 [makeBinFile [string repeat X 512] file21 $cfs]
    set file22 [makeBinFile [string repeat X 1] file22 $cfs]
    set file23 [makeBinFile [string repeat X 131] file23 $cfs]
    # flush pages by changing compression
    file attribute $cfs -compression zlib
    # one big file for many pages
    set file3 [makeBinFile [string repeat {ABC} 1368] file3 $cfs]
} -body {
    # file1 should be equal to compressed size of page#0
    assertLt [file attributes $file1 -compsize] 2048
    assertEq [file attributes $file1 -compsize] [dict get [file attributes $cfs -pages 0] compsize]
    # sum of files 21/22/23 should be equal to compressed size (+/- 1) of page#1
    assertLt [file attributes $file21 -compsize] 512
    assertLt [file attributes $file23 -compsize] 131
    assertLe [expr {
        abs ([dict get [file attributes $cfs -pages 1] compsize]
            - [file attributes $file21 -compsize]
            - [file attributes $file22 -compsize]
            - [file attributes $file23 -compsize])
    }] 1
    assertLt [file attributes $file3 -compsize] 7001
    # file3 should be equal to sum of pages #2 / #3 / #4
    assertEq [file attributes $file3 -compsize] [expr {
        [dict get [file attributes $cfs -pages 2] compsize] +
        [dict get [file attributes $cfs -pages 3] compsize] +
        [dict get [file attributes $cfs -pages 4] compsize]
    }]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-44.2 "Test attribute -compsize, set" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 1024 -smallfilesize 100 -smallfilebuffer 1024
    # big file, will be stored to pages
    set file1 [makeBinFile [string repeat {TEST} 500] "testfile1" $cfs]
} -body {
    file attributes $file1 -compsize 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-compsize" is read-only}

test cookfsVfs-45.1.1 "Test attribute -blocks, get" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 2048 -smallfilesize 1024 -smallfilebuffer 2048
    # one file for 1 page
    set file1 [makeBinFile [string repeat X 2048] file1 $cfs]
    # many files in 1 page
    set file21 [makeBinFile [string repeat X 512] file21 $cfs]
    set file22 [makeBinFile [string repeat X 1] file22 $cfs]
    set file23 [makeBinFile [string repeat X 131] file23 $cfs]
    # flush pages by changing compression
    file attribute $cfs -compression none
    # one big file for many pages, some pages are duplicated
    set file3 [makeBinFile [string repeat X 7001] file3 $cfs]
    # one big file for many different pages
    set file4 [makeBinFile [string repeat {ABC} 1368] file4 $cfs]
} -body {
    assertEq [file attributes $file1 -blocks] {{page 0 offset 0 size 2048}}
    assertEq [file attributes $file21 -blocks] {{page 1 offset 0 size 512}}
    assertEq [file attributes $file22 -blocks] {{page 1 offset 512 size 1}}
    assertEq [file attributes $file23 -blocks] {{page 1 offset 513 size 131}}
    assertEq [file attributes $file3 -blocks] {{page 0 offset 0 size 2048} {page 0 offset 0 size 2048} {page 0 offset 0 size 2048} {page 2 offset 0 size 857}}
    assertEq [file attributes $file4 -blocks] {{page 3 offset 0 size 2048} {page 4 offset 0 size 2048} {page 5 offset 0 size 8}}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-45.2 "Test attribute -blocks, set" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 1024 -smallfilesize 100 -smallfilebuffer 1024
    # big file, will be stored to pages
    set file1 [makeBinFile [string repeat {TEST} 500] "testfile1" $cfs]
} -body {
    file attributes $file1 -blocks 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-blocks" is read-only}

test cookfsVfs-46.1.1 "Test attribute -compression (file), get" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 2048 -smallfilesize 1024 -smallfilebuffer 2048
    # file1 compression is 'none'
    set file1 [makeBinFile [string repeat 1 128] file1 $cfs]
    file attributes $cfs -compression zlib
    # file2 compression is 'zlib'
    set file2 [makeBinFile [string repeat 2 128] file2 $cfs]
    # file3 compression is 'none'
    file attributes $cfs -compression none
    set file3 [makeBinFile [string repeat 3 128] file3 $cfs]
    # file4 compression is 'zlib:2'
    file attributes $cfs -compression zlib:2
    set file4 [makeBinFile [string repeat 4 2048] file4 $cfs]
    # file5 compression is 'zlib:2', but it is in smallfilebuffer, thus its compression
    # will be 'none'
    set file5 [makeBinFile [string repeat 5 128] file5 $cfs]
} -body {
    assertEq [file attributes $file1 -compression] {none}
    assertEq [file attributes $file2 -compression] {zlib}
    assertEq [file attributes $file3 -compression] {none}
    assertEq [file attributes $file4 -compression] {zlib:2}
    assertEq [file attributes $file5 -compression] {none}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-46.2 "Test attribute -compression (file), set" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 1024 -smallfilesize 100 -smallfilebuffer 1024
    # big file, will be stored to pages
    set file1 [makeBinFile [string repeat {TEST} 500] "testfile1" $cfs]
} -body {
    file attributes $file1 -compression 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-compression" is read-only}

test cookfsVfs-47.1.1 "Test attribute -relative, get" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 2048 -smallfilesize 1024 -smallfilebuffer 2048
    # file1 compression is 'none'
    set file1 [makeBinFile [string repeat 1 128] file1 $cfs]
    set dir1 [makeDirectory "foo" $cfs]
    set file2 [makeBinFile {} file2 $dir1]
    set dir2 [makeDirectory "bar" $dir1]
    set file3 [makeBinFile {} file3 $dir2]
} -body {
    assertEq [file attributes $cfs -relative] ""
    assertEq [file attributes $file1 -relative] "file1"
    assertEq [file attributes $file2 -relative] "foo/file2"
    assertEq [file attributes $file3 -relative] "foo/bar/file3"
    assertEq [file attributes $dir1 -relative] "foo"
    assertEq [file attributes $dir2 -relative] "foo/bar"
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-47.2 "Test attribute -relative, set" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 1024 -smallfilesize 100 -smallfilebuffer 1024
    # big file, will be stored to pages
    set file1 [makeBinFile [string repeat {TEST} 500] "testfile1" $cfs]
} -body {
    file attributes $file1 -relative 1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-relative" is read-only}

cleanupTests

