
tcltest::test cookfsVfs-1.1.1 "Mount empty filename (unix)" -constraints unix -setup {
} -body {
    vfs::cookfs::Mount "" ""
} -cleanup {
} -returnCodes {error} -match glob -result {Unable to create Cookfs object: couldn't open "*": illegal operation on a directory}

tcltest::test cookfsVfs-1.1.2 "Mount empty filename (windows)" -constraints win -setup {
} -body {
    vfs::cookfs::Mount "" ""
} -cleanup {
} -returnCodes {error} -match glob -result {Unable to create Cookfs object: couldn't open "*": permission denied}

tcltest::test cookfsVfs-1.2 "Mount non-existant file as read-write" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
} -body {
    set fsid [vfs::cookfs::Mount $file $file]
    vfs::unmount $file
    set fsid
} -cleanup {
    tcltest::removeFile $file
    unset fsid
} -returnCodes {ok} -match glob -result {::cookfs::*::vfs::mount*}

tcltest::test cookfsVfs-1.3 "Mount non-existant file as read-only" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
} -body {
    vfs::cookfs::Mount -readonly $file $file
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {error} -result {Unable to create Cookfs object: index not found}

tcltest::test cookfsVfs-1.4 "Remounting archive" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
} -body {
    vfs::cookfs::Mount $file $file
    set fh [open [file join $file testfile] w]
    fconfigure $fh -translation binary
    puts $fh TEST
    close $fh
    vfs::unmount $file

    vfs::cookfs::Mount $file $file
    file exists [file join $file testfile]
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result 1

tcltest::test cookfsVfs-1.5 "Remounting archive using -pagesobject" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
} -body {
    vfs::cookfs::Mount $file $file
    set fh [open [file join $file testfile] w]
    fconfigure $fh -translation binary
    puts $fh TEST
    close $fh
    vfs::unmount $file

    set p [cookfs::pages $file]
    set h [vfs::cookfs::Mount $file $file -pagesobject $p]
    string equal [$h getpages] $p
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result 1

tcltest::test cookfsVfs-1.6 "Remounting archive using -fsindexobject" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
} -body {
    vfs::cookfs::Mount $file $file
    set fh [open [file join $file testfile] w]
    fconfigure $fh -translation binary
    puts $fh TEST
    close $fh
    vfs::unmount $file

    set p [cookfs::pages $file]
    set i [cookfs::fsindex [$p index]]
    set h [vfs::cookfs::Mount $file $file -pagesobject $p -fsindexobject $i]
    string equal [$h getindex] $i
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result 1

tcltest::test cookfsVfs-1.7 "Setting metadata on mount" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
} -body {
    vfs::cookfs::Mount $file $file
    set fh [open [file join $file testfile] w]
    fconfigure $fh -translation binary
    puts $fh TEST
    close $fh
    vfs::unmount $file

    set h [vfs::cookfs::Mount $file $file -setmetadata {test1 1 test2 2}]
    vfs::unmount $file

    set h [vfs::cookfs::Mount $file $file]
    format %s,%s [$h getmetadata test1] [$h getmetadata test2]
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result 1,2

tcltest::test cookfsVfs-1.8 "Mounting as volume" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
} -body {
    vfs::cookfs::Mount $file $file
    set fh [open [file join $file testfile] w]
    fconfigure $fh -translation binary
    puts $fh TEST
    close $fh
    vfs::unmount $file

    set h [vfs::cookfs::Mount $file test:/ -volume]
    expr {([lsearch -exact [file volumes] test:/]>=0)?1:0}
} -cleanup {
    catch {vfs::unmount $file}
    catch {vfs::unmount test:/}
    tcltest::removeFile $file
} -returnCodes {ok} -result 1

tcltest::test cookfsVfs-1.9 "Test storing same files" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
} -body {
    vfs::cookfs::Mount $file $file -smallfilesize 40960
    tcltest::makeFile [string repeat "TEST"    64] [file join $file test1a]
    tcltest::makeFile [string repeat "TEST"  1024] [file join $file test2a]
    tcltest::makeFile [string repeat "TEST"    64] [file join $file test1b]
    tcltest::makeFile [string repeat "TEST" 16384] [file join $file test4a]
    tcltest::makeFile [string repeat "TEST"  4096] [file join $file test3a]
    tcltest::makeFile [string repeat "TEST"  1024] [file join $file test2b]
    tcltest::makeFile [string repeat "TEST"  4096] [file join $file test3b]
    tcltest::makeFile [string repeat "TEST" 16384] [file join $file test4b]
    vfs::unmount $file

    set h [vfs::cookfs::Mount $file $file -readonly]
    if {![fsindexEqual [[$h getindex] get test4a] [[$h getindex] get test4b]]} {
        error "Index for test4 differs: [[set ${h}(index)] get test4a] != [[set ${h}(index)] get test4b]"
    }
    if {![fsindexEqual [[$h getindex] get test3a] [[$h getindex] get test3b]]} {
        error "Index for test3 differs: [[set ${h}(index)] get test3a] != [[set ${h}(index)] get test3b]"
    }
    if {![fsindexEqual [[$h getindex] get test2a] [[$h getindex] get test2b]]} {
        error "Index for test2 differs: [[set ${h}(index)] get test2a] != [[set ${h}(index)] get test2b]"
    }
    if {![fsindexEqual [[$h getindex] get test1a] [[$h getindex] get test1b]]} {
        error "Index for test1 differs: [[set ${h}(index)] get test1a] != [[set ${h}(index)] get test1b]"
    }
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok}

tcltest::test cookfsVfs-2.1 "Test compressing entire directory structure" -setup {
    set dir [tcltest::makeDirectory cookfs.vfs]
    makeSimpleTree $dir
    set file [tcltest::makeFile {} cookfs.cfs]
} -body {
    vfs::cookfs::Mount $file $file
    file copy -force $dir [file join $file vfs]
    testIfEqual $dir [file join $file vfs]
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeDirectory $dir
    tcltest::removeFile $file
} -returnCodes {ok} -result 1

tcltest::test cookfsVfs-2.2 "Test compressing entire directory structure after remount" -setup {
    set dir [tcltest::makeDirectory cookfs.vfs]
    makeSimpleTree $dir
    set file [tcltest::makeFile {} cookfs.cfs]
} -body {
    vfs::cookfs::Mount $file $file
    file copy -force $dir [file join $file vfs]
    vfs::unmount $file
    vfs::cookfs::Mount $file $file
    testIfEqual $dir [file join $file vfs]
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeDirectory $dir
    tcltest::removeFile $file
} -returnCodes {ok} -result 1

tcltest::test cookfsVfs-2.3 "Test correct storing of empty files or new directory as only change in existing cookfs" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
} -body {
    set fsid [vfs::cookfs::Mount $file $file]

    set fh [open $file/file1 w]
    fconfigure $fh -translation binary
    puts $fh [string repeat TEST 1024]
    close $fh
    vfs::unmount $file

    set fsid [vfs::cookfs::Mount $file $file]
    # create 2 files so length of new index is not smaller than previously
    close [open $file/file2 w]
    close [open $file/file34 w]
    vfs::unmount $file

    set fsid [vfs::cookfs::Mount $file $file]
    if {![file exists $file/file2]} {
        error "Unable to find file2 in archive"
    }
    # create 2 directories so length of new index is not smaller than previously
    file mkdir $file/dir1
    file mkdir $file/dir23
    vfs::unmount $file

    set fsid [vfs::cookfs::Mount $file $file]
    if {![file exists $file/dir1]} {
        error "Unable to find dir1 in archive"
    }
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok}

tcltest::test cookfsVfs-3.1 "Test creating files in non-existant directory in VFS" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
    set fsid [vfs::cookfs::Mount $file $file]
} -body {
    close [open $file/somedir/file w]
} -cleanup {
    vfs::unmount $file
    tcltest::removeFile $file
} -returnCodes {error} -match glob -result "*no such file or directory*"

tcltest::test cookfsVfs-3.2 "Test creating files in file in VFS" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
    set fsid [vfs::cookfs::Mount $file $file]
} -body {
    close [open $file/file w]
    close [open $file/file/otherfile w]
} -cleanup {
    vfs::unmount $file
    tcltest::removeFile $file
} -returnCodes {error} -match glob -result "*not a directory*"

tcltest::test cookfsVfs-3.3 "Test creating directories in file in VFS" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
    set fsid [vfs::cookfs::Mount $file $file]
} -body {
    close [open $file/file w]
    file mkdir $file/file/somedir
} -cleanup {
    vfs::unmount $file
    tcltest::removeFile $file
} -returnCodes {error} -match glob -result "*file already exists*"

tcltest::test cookfsVfs-3.4 "Test creating directories and files" -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
    set fsid [vfs::cookfs::Mount $file $file]
} -body {
    file mkdir $file/dir1
    file mkdir $file/dir2
    file mkdir $file/dir2/dir3
    close [open $file/file2 w]
    close [open $file/dir2/file4 w]
    close [open $file/dir2/dir3/file5 w]
    vfs::unmount $file
    set fsid [vfs::cookfs::Mount $file $file]
    concat \
        [lsort [glob -tails -directory $file * */* */*/*]] \
        [lsort [glob -tails -directory $file -type d -nocomplain * */* */*/*]] \
        [lsort [glob -tails -directory $file -type f -nocomplain * */* */*/*]]
} -cleanup {
    vfs::unmount $file
    tcltest::removeFile $file
} -returnCodes {ok} -result {dir1 dir2 dir2/dir3 dir2/dir3/file5 dir2/file4 file2 dir1 dir2 dir2/dir3 dir2/dir3/file5 dir2/file4 file2}

tcltest::test cookfsVfs-4.2 "Test add-aside feature using fsid aside command" -constraints cookfsAside -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
    set file2 [tcltest::makeFile {} cookfs2.cfs]
    set fsid [vfs::cookfs::Mount $file $file]
    close [open $file/file1 w]
    file mkdir $file/dir1
    vfs::unmount $file
} -body {
    set fsid [vfs::cookfs::Mount -readonly $file $file]
    $fsid aside $file2
    file mkdir $file/dir2
    close [open $file/file2 w]
    vfs::unmount $file

    set fsid [vfs::cookfs::Mount -readonly $file $file]
    $fsid aside $file2
    lsort [glob -directory $file -tails *]
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
    tcltest::removeFile $file2
} -returnCodes {ok} -result {dir1 dir2 file1 file2}

tcltest::test cookfsVfs-4.4 "Test write to memory feature using fsid writetomemory command" -constraints cookfsAside -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
    set fsid [vfs::cookfs::Mount $file $file]
    close [open $file/file1 w]
    file mkdir $file/dir1
    vfs::unmount $file
} -body {
    set fsid [vfs::cookfs::Mount -readonly $file $file]
    $fsid writetomemory
    file mkdir $file/dir2
    close [open $file/file2 w]
    vfs::unmount $file

    set fsid [vfs::cookfs::Mount -readonly $file $file]
    lsort [glob -directory $file -tails *]
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result {dir1 file1}

tcltest::test cookfsVfs-5.1 "Test getting metadata using fsid getmetadata command without default value" -constraints cookfsMetadata -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
    set fsid [vfs::cookfs::Mount $file $file]
} -body {
    vfs::unmount $file

    set fsid [vfs::cookfs::Mount -readonly $file $file]
    $fsid getmetadata nonexistant
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {error} -result {Parameter not defined}

tcltest::test cookfsVfs-5.2 "Test getting metadata using fsid getmetadata command with default value" -constraints cookfsMetadata -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
    set fsid [vfs::cookfs::Mount $file $file]
} -body {
    vfs::unmount $file

    set fsid [vfs::cookfs::Mount -readonly $file $file]
    $fsid getmetadata nonexistant 12
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result {12}

tcltest::test cookfsVfs-5.3 "Test setting metadata using fsid setmetadata command" -constraints cookfsMetadata -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
    set fsid [vfs::cookfs::Mount $file $file]
} -body {
    $fsid setmetadata somename othervalue
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok}

tcltest::test cookfsVfs-5.4 "Test setting metadata in a read-only mount" -constraints cookfsMetadata -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
    set fsid [vfs::cookfs::Mount $file $file]
} -body {
    vfs::unmount $file

    set fsid [vfs::cookfs::Mount -readonly $file $file]
    $fsid setmetadata somename othervalue
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {error} -result {Archive is read-only}

tcltest::test cookfsVfs-5.5 "Test setting and getting metadata" -constraints cookfsMetadata -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
    set fsid [vfs::cookfs::Mount $file $file]
} -body {
    $fsid setmetadata somename othervalue
    vfs::unmount $file

    set fsid [vfs::cookfs::Mount -readonly $file $file]
    $fsid getmetadata somename
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result {othervalue}

tcltest::test cookfsVfs-6.1 "Test crc32 based VFS and page handling" -constraints cookfsMetadata -setup {
    set file [tcltest::makeFile {} cookfs.cfs]
} -body {
    vfs::cookfs::Mount -pagehash crc32 $file $file
    set fh [open $file/test1 w]
    fconfigure $fh -translation binary
    puts $fh "TEST TEST"
    close $fh
    vfs::unmount $file

    set h [vfs::cookfs::Mount $file $file]
    set fh [open $file/test2 w]
    fconfigure $fh -translation binary
    puts $fh "TEST TEST"
    close $fh

    [$h getpages] length
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result {1}

tcltest::test cookfsVfs-7.1 "Test filesize command" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    set fh [open $file w]
    fconfigure $fh -translation binary
    puts -nonewline $fh [string repeat "TEST" 1024]
    close $fh
} -body {
    set fsid [vfs::cookfs::Mount -smallfilesize 8192 -compression none $file $file]
    set fh [open [file join $file testfile1] w]
    fconfigure $fh -translation binary
    puts -nonewline $fh [string repeat "Test0001" 4096]
    close $fh
    set fh [open [file join $file testfile2] w]
    fconfigure $fh -translation binary
    puts -nonewline $fh [string repeat "Test0002" 4096]
    close $fh
    $fsid filesize
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result 69634

tcltest::test cookfsVfs-7.2 "Test filesize command" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    set fh [open $file w]
    close $fh
} -body {
    set fsid [vfs::cookfs::Mount -smallfilesize 8192 -compression none $file $file]
    set fh [open [file join $file testfile1] w]
    fconfigure $fh -translation binary
    puts -nonewline $fh [string repeat "Test0001" 4096]
    close $fh
    set fh [open [file join $file testfile2] w]
    fconfigure $fh -translation binary
    puts -nonewline $fh [string repeat "Test0002" 4096]
    close $fh
    set fh [open [file join $file testfile3] w]
    fconfigure $fh -translation binary
    puts -nonewline $fh [string repeat "Test0002" 128]
    close $fh
    $fsid smallfilebuffersize
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result 1024

tcltest::test cookfsVfs-8.1 "Test modifying file mtime" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    set fh [open $file w]
    close $fh
} -body {
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    set fh [open [file join $file testfile1] w]
    fconfigure $fh -translation binary
    puts -nonewline $fh [string repeat "Test0001" 4096]
    close $fh
    file mtime [file join $file testfile1] 1
    catch {vfs::unmount $file}
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    if {[file mtime [file join $file testfile1]] != "1"} {
        error "Invalid mtime after first pass"
    }
    file mtime [file join $file testfile1] 1342177280
    catch {vfs::unmount $file}
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    file mtime [file join $file testfile1]
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result 1342177280

tcltest::test cookfsVfs-9.1 "Test deleting files" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    set fh [open $file w]
    close $fh
} -body {
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    close [open [file join $file testfile1] w]
    close [open [file join $file testfile2] w]
    file mkdir [file join $file testdir1]
    file mkdir [file join $file testdir2]
    close [open [file join $file testdir2/testfile3] w]
    close [open [file join $file testdir2/testfile4] w]
    catch {vfs::unmount $file}
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    file delete -force [file join $file testfile1]
    catch {vfs::unmount $file}
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    join [lsort [glob -tails -directory $file * */*]] ,
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result {testdir1,testdir2,testdir2/testfile3,testdir2/testfile4,testfile2}

tcltest::test cookfsVfs-9.2 "Test deleting empty directories" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    set fh [open $file w]
    close $fh
} -body {
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    close [open [file join $file testfile1] w]
    close [open [file join $file testfile2] w]
    file mkdir [file join $file testdir1]
    file mkdir [file join $file testdir2]
    close [open [file join $file testdir2 testfile3] w]
    close [open [file join $file testdir2 testfile4] w]
    catch {vfs::unmount $file}
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    file delete -force [file join $file testdir1]
    catch {vfs::unmount $file}
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    join [lsort [glob -tails -directory $file * */*]] ,
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result {testdir2,testdir2/testfile3,testdir2/testfile4,testfile1,testfile2}

tcltest::test cookfsVfs-9.3 "Test deleting non-empty directories" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    set fh [open $file w]
    close $fh
} -body {
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    close [open [file join $file testfile1] w]
    close [open [file join $file testfile2] w]
    file mkdir [file join $file testdir1]
    file mkdir [file join $file testdir2]
    close [open [file join $file testdir2 estfile3] w]
    close [open [file join $file testdir2 testfile4] w]
    catch {vfs::unmount $file}
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    file delete -force [file join $file testdir2]
    catch {vfs::unmount $file}
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    join [lsort [glob -tails -directory $file * */*]] ,
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result {testdir1,testfile1,testfile2}

tcltest::test cookfsVfs-9.4 "Test deleting non-empty directories with complex structure" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    set fh [open $file w]
    close $fh
} -body {
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    close [open [file join $file testfile1] w]
    close [open [file join $file testfile2] w]
    file mkdir [file join $file testdir1]
    file mkdir [file join $file testdir2]
    file mkdir [file join $file testdir2 testdir3]
    file mkdir [file join $file testdir2 testdir3 testdir4]
    close [open [file join $file testdir2 testfile3] w]
    close [open [file join $file testdir2 testfile4] w]
    close [open [file join $file testdir2 testdir3 testfile5] w]
    close [open [file join $file testdir2 testdir3 testfile6] w]
    catch {vfs::unmount $file}
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    file delete -force [file join $file testdir2]
    catch {vfs::unmount $file}
    set fsid [vfs::cookfs::Mount -compression none $file $file]
    join [lsort [glob -tails -directory $file * */*]] ,
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok} -result {testdir1,testfile1,testfile2}

tcltest::test cookfsVfs-10.1 "Test changing compression without remounting" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    set fh [open $file w]
    close $fh
} -body {
    set fsid [vfs::cookfs::Mount $file $file -compression zlib -smallfilesize 32768 \
	-compresscommand testcompressraw -decompresscommand testdecompressraw -alwayscompress]
    if {[$fsid compression] != "zlib"} {
	error "Getting compression does not return \"zlib\""
    }

    set fh [open [file join $file testfile1] w]
    fconfigure $fh -translation binary
    puts -nonewline $fh [string repeat "TEST" 256]
    close $fh

    $fsid compression none
    if {[$fsid compression] != "none"} {
	error "Getting compression does not return \"none\""
    }

    set fh [open [file join $file testfile2] w]
    fconfigure $fh -translation binary
    puts -nonewline $fh [string repeat "test" 256]
    close $fh

    $fsid compression custom
    if {[$fsid compression] != "custom"} {
	error "Getting compression does not return \"custom\""
    }
    vfs::unmount $file

    set fsid [vfs::cookfs::Mount $file $file -readonly \
	-compresscommand testcompressraw -decompresscommand testdecompressraw -alwayscompress]
    set idx [[$fsid getpages] index]
    vfs::unmount $file

    set fh [open $file r]
    fconfigure $fh -translation binary
    set fc [read $fh]
    close $fh

    if {[string first [string repeat "TEST" 256] $fc] >= 0} {
        error "File testfile1 should be compressed"
    }

    if {[string first [string repeat "test" 256] $fc] < 0} {
        error "File testfile2 should not be compressed"
    }

    if {[string first [testcompressraw $idx] $fc] < 0} {
        error "Index not found"
    }
} -cleanup {
    catch {vfs::unmount $file}
    tcltest::removeFile $file
} -returnCodes {ok}

tcltest::test cookfsVfs-11.1 "Test unmount using fsid" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set result [list]
    lappend result [file type $file]
    set fsid [vfs::cookfs::Mount $file $file]
    lappend result [file type $file]
    # ensure that mount handler command exists
    lappend result [llength [info commands $fsid]]
    cookfs::Unmount $fsid
    lappend result [file type $file]
    # ensure that mount handler command deleted
    lappend result [llength [info commands $fsid]]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result {file directory 1 file 0}

tcltest::test cookfsVfs-11.2 "Test unmount using mount point" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set result [list]
    lappend result [file type $file]
    set fsid [vfs::cookfs::Mount $file $file]
    lappend result [file type $file]
    # ensure that mount handler command exists
    lappend result [llength [info commands $fsid]]
    cookfs::Unmount $file
    lappend result [file type $file]
    # ensure that mount handler command deleted
    lappend result [llength [info commands $fsid]]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result {file directory 1 file 0}

tcltest::test cookfsVfs-11.3 "Test unmount using mount point (relative)" -setup {
    set file pages.cfs
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set result [list]
    lappend result [file type $file]
    set fsid [vfs::cookfs::Mount $file $file]
    lappend result [file type $file]
    # ensure that mount handler command exists
    lappend result [llength [info commands $fsid]]
    cookfs::Unmount $file
    lappend result [file type $file]
    # ensure that mount handler command deleted
    lappend result [llength [info commands $fsid]]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result {file directory 1 file 0}

tcltest::test cookfsVfs-11.4 "Test unmount using vfs::unmount" -constraints packageTclvfs -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set result [list]
    lappend result [file type $file]
    set fsid [vfs::cookfs::Mount $file $file]
    lappend result [file type $file]
    # ensure that mount handler command exists
    lappend result [llength [info commands $fsid]]
    vfs::unmount $file
    lappend result [file type $file]
    # ensure that mount handler command deleted
    lappend result [llength [info commands $fsid]]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result {file directory 1 file 0}

tcltest::test cookfsVfs-12.1 "Test registration in tclvfs, should be registered by default" -constraints packageTclvfs -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set result [list]
    lappend result [file type $file]
    set fsid [vfs::cookfs::Mount $file $file]
    lappend result [file type $file]
    # ensure that mount handler command exists
    lappend result [llength [info commands $fsid]]
    # Don't change this to cookfs::Unmount. This test checks vfs::unmount command.
    # vfs::unmount should unmount cookfs successfully.
    vfs::unmount $file
    lappend result [file type $file]
    # ensure that mount handler command deleted
    lappend result [llength [info commands $fsid]]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result {file directory 1 file 0}

# Run this test with c-vfs only, as tcl-vfs will not work if cookfs is not registered with tclvfs.
tcltest::test cookfsVfs-12.2 "Test registration in tclvfs, should not be registered due to -noregister" -constraints { enabledCVfs packageTclvfs } -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set result [list]
    lappend result [file type $file]
    set fsid [vfs::cookfs::Mount -noregister $file $file]
    lappend result [file type $file]
    # ensure that mount handler command exists
    lappend result [llength [info commands $fsid]]
    # this should fail
    lappend result [catch { vfs::unmount $file }]
    # ensure that mount handler command exists
    lappend result [llength [info commands $fsid]]
    lappend result [file type $file]
    # this has to be successful
    lappend result [catch { cookfs::Unmount $fsid }]
    lappend result [file type $file]
    # ensure that mount handler command deleted
    lappend result [llength [info commands $fsid]]
} -cleanup {
    catch { cookfs::Unmount $fsid }
    tcltest::removeFile $file
} -result {file directory 1 1 1 directory 0 file 0}

tcltest::test cookfsVfs-12.3 "Test that cookfs::Unmount invoked with fsid unregister cookfs in tclvfs" -constraints packageTclvfs -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set result [list]
    lappend result [file type $file]
    set fsid [vfs::cookfs::Mount $file $file]
    lappend result [file type $file]
    # ensure that mount handler command exists
    lappend result [llength [info commands $fsid]]
    # this has to be successful
    lappend result [catch { cookfs::Unmount $fsid }]
    lappend result [file type $file]
    # ensure that mount handler command exists
    lappend result [llength [info commands $fsid]]
    # this should fail with:
    # can't read "_unmountCmd(/w/projects/build/_cookfs/_tmp/pages.cfs)": no such element in array
    # because cookfs::Unmount unregistered cookfs from tclvfs
    lappend result [catch { vfs::unmount $file } err]
    lappend result $err
    lappend result [file type $file]
    # ensure that mount handler command deleted
    lappend result [llength [info commands $fsid]]
} -cleanup {
    catch { cookfs::Unmount $fsid }
    tcltest::removeFile $file
} -match glob -result {file directory 1 0 file 0 1 {can't read "_unmountCmd(*)": no such element in array} file 0}

tcltest::test cookfsVfs-12.4 "Test that cookfs::Unmount invoked with mount path unregister cookfs in tclvfs" -constraints packageTclvfs -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set result [list]
    lappend result [file type $file]
    set fsid [vfs::cookfs::Mount $file $file]
    lappend result [file type $file]
    # ensure that mount handler command exists
    lappend result [llength [info commands $fsid]]
    # this has to be successful
    lappend result [catch { cookfs::Unmount $file }]
    lappend result [file type $file]
    # ensure that mount handler command deleted
    lappend result [llength [info commands $fsid]]
    # this should fail with:
    # can't read "_unmountCmd(/w/projects/build/_cookfs/_tmp/pages.cfs)": no such element in array
    # because cookfs::Unmount unregistered cookfs from tclvfs
    lappend result [catch { vfs::unmount $file } err]
    lappend result $err
    lappend result [file type $file]
} -cleanup {
    catch { cookfs::Unmount $fsid }
    tcltest::removeFile $file
} -match glob -result {file directory 1 0 file 0 1 {can't read "_unmountCmd(*)": no such element in array} file}

tcltest::test cookfsVfs-13.1 "Test -bootstrap option for cookfs::Mount, when opening new archive" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set bootstrap "TEST BOOTSTRAP"
    set fsid [vfs::cookfs::Mount -bootstrap $bootstrap $file $file]
    vfs::unmount $file
    set fsid [vfs::cookfs::Mount $file $file]
    expr { [[$fsid getpages] get 0] eq $bootstrap }
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result 1

tcltest::test cookfsVfs-13.2 "Test -bootstrap option for cookfs::Mount is ignored, when opening existing archive" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
    set bootstrap "TEST BOOTSTRAP"
    set fsid [vfs::cookfs::Mount -bootstrap $bootstrap $file $file]
    vfs::unmount $file
} -body {
    set fsid [vfs::cookfs::Mount -bootstrap "XXXX" $file $file]
    expr { [[$fsid getpages] get 0] eq $bootstrap }
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result 1

tcltest::test cookfsVfs-13.3 "Test -bootstrap option for cookfs::Mount, ignore empty bootstrap" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set fsid [vfs::cookfs::Mount -bootstrap "" $file $file]
    [$fsid getpages] length
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result 0

tcltest::test cookfsVfs-14.1 "Test -pagehash option for cookfs::Mount, when opening new archive (md5)" -constraints enabledCPages -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set hash "md5"
    set fsid [vfs::cookfs::Mount -pagehash $hash $file $file]
    set result [list]
    lappend result [expr { [[$fsid getpages] hash] eq $hash }]
    lappend result [expr { [[$fsid getindex] getmetadata cookfs.pagehash] eq $hash }]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result {1 1}

tcltest::test cookfsVfs-14.2 "Test -pagehash option for cookfs::Mount, when opening new archive (crc32)" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set hash "crc32"
    set fsid [vfs::cookfs::Mount -pagehash $hash $file $file]
    set result [list]
    lappend result [expr { [[$fsid getpages] hash] eq $hash }]
    lappend result [expr { [[$fsid getindex] getmetadata cookfs.pagehash] eq $hash }]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result {1 1}

tcltest::test cookfsVfs-14.3 "Test -pagehash option for cookfs::Mount, when reopening (md5)" -constraints enabledCPages -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set hash "md5"
    vfs::cookfs::Mount -pagehash $hash $file $file
    # make sure that archive is not empty, so hash algo will not reset after reopen
    tcltest::makeFile {} temp1 $file
    vfs::unmount $file
    set fsid [vfs::cookfs::Mount $file $file]
    set result [list]
    lappend result [expr { [[$fsid getpages] hash] eq $hash }]
    lappend result [expr { [[$fsid getindex] getmetadata cookfs.pagehash] eq $hash }]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result {1 1}

tcltest::test cookfsVfs-14.4 "Test -pagehash option for cookfs::Mount, when reopening (crc32)" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set hash "crc32"
    vfs::cookfs::Mount -pagehash $hash $file $file
    # make sure that archive is not empty, so hash algo will not reset after reopen
    tcltest::makeFile {} temp1 $file
    vfs::unmount $file
    set fsid [vfs::cookfs::Mount $file $file]
    set result [list]
    lappend result [expr { [[$fsid getpages] hash] eq $hash }]
    lappend result [expr { [[$fsid getindex] getmetadata cookfs.pagehash] eq $hash }]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result {1 1}


tcltest::test cookfsVfs-14.5 "Test -pagehash option for cookfs::Mount is ignored, when opening existing archive" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set hash "crc32"
    vfs::cookfs::Mount -pagehash $hash $file $file
    # make sure that archive is not empty
    tcltest::makeFile {} temp1 $file
    vfs::unmount $file
    set fsid [vfs::cookfs::Mount -pagehash "md5" $file $file]
    set result [list]
    lappend result [expr { [[$fsid getpages] hash] eq $hash }]
    lappend result [expr { [[$fsid getindex] getmetadata cookfs.pagehash] eq $hash }]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result {1 1}

# Here we just check if "<fsindex> getmetadata cookfs.pagehash" ends with an error.
# Actual values are not interested.
tcltest::test cookfsVfs-14.6 "Test that cookfs.pagehash metadata exists by default" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set result [list]
    set fsid [vfs::cookfs::Mount $file $file]
    lappend result [[$fsid getindex] getmetadata cookfs.pagehash]
    # make sure that archive is not empty
    tcltest::makeFile {} temp1 $file
    vfs::unmount $file
    set fsid [vfs::cookfs::Mount $file $file]
    lappend result [[$fsid getindex] getmetadata cookfs.pagehash]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -match glob -result {* *}

tcltest::test cookfsVfs-14.7 "Test that cookfs.pagehash metadata matches actual pages hash" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set result [list]
    set fsid [vfs::cookfs::Mount $file $file]
    lappend result [string equal [[$fsid getpages] hash] [[$fsid getindex] getmetadata cookfs.pagehash]]
    # make sure that archive is not empty
    tcltest::makeFile {} temp1 $file
    vfs::unmount $file
    set fsid [vfs::cookfs::Mount $file $file]
    lappend result [string equal [[$fsid getpages] hash] [[$fsid getindex] getmetadata cookfs.pagehash]]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -result {1 1}

tcltest::test cookfsVfs-14.8 "Test unknown hash value" -setup {
    set file [tcltest::makeFile {} pages.cfs]
    # make sure no additional data is written to file
    close [open $file w]
} -body {
    set result [list]
    set fsid [vfs::cookfs::Mount -pagehash foo $file $file]
} -cleanup {
    catch { vfs::unmount $file }
    tcltest::removeFile $file
} -returnCodes error -result {bad hash "foo": must be md5 or crc32}

