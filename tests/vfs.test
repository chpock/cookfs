source [file join [file dirname [info script]] common.tcl]

test cookfsVfs-1.1.1.1 "Mount empty filename (unix)" -constraints {unix tcl86} -body {
    cookfs::Mount "" ""
} -match glob -error {Unable to create Cookfs object: couldn't open "*": illegal operation on a directory}

test cookfsVfs-1.1.1.2 "Mount empty filename (unix)" -constraints {unix tcl90} -body {
    cookfs::Mount "" ""
} -match glob -error {Unable to create Cookfs object: couldn't open "*": is a directory}

test cookfsVfs-1.1.2 "Mount empty filename (windows)" -constraints win -body {
    cookfs::Mount "" ""
} -match glob -error {Unable to create Cookfs object: couldn't open "*": permission denied}

test cookfsVfs-1.2 "Mount non-existant file as read-write" -setup {
    set file [makeFile {} cookfs.cfs]
    variable fsid
} -body {
    set fsid [cookfs::Mount $file $file]
    cookfs::Unmount $file
    set fsid
} -match glob -result {::cookfs::*::vfs::mount*}

test cookfsVfs-1.3 "Mount non-existant file as read-only" -setup {
    set file [makeFile {} cookfs.cfs]
} -body {
    cookfs::Mount -readonly $file $file
} -cleanup {
    catch { cookfs::Unmount $file }
} -error {Unable to create Cookfs object: signature not found}

test cookfsVfs-1.4 "Remounting archive" -setup {
    set file [makeFile {} cookfs.cfs]
} -body {
    cookfs::Mount $file $file
    makeBinFile {} testfile $file
    cookfs::Unmount $file

    cookfs::Mount $file $file
    file exists [file join $file testfile]
} -cleanup {
    cookfs::Unmount $file
} -result 1

test cookfsVfs-1.5 "Remounting archive using -pagesobject" -constraints {enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    variable p
    variable h
} -body {
    cookfs::Mount $file $file
    makeBinFile {} testfile $file
    cookfs::Unmount $file

    set p [cookfs::pages $file]
    set h [cookfs::Mount $file $file -pagesobject $p]
    string equal [$h getpages] $p
} -cleanup {
    cookfs::Unmount $file
} -result 1

test cookfsVfs-1.6 "Remounting archive using -fsindexobject" -constraints {enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    variable p
    variable i
    variable h
} -body {
    cookfs::Mount $file $file
    makeBinFile {} testfile $file
    cookfs::Unmount $file

    set p [cookfs::pages $file]
    set i [cookfs::fsindex [$p index]]
    set h [cookfs::Mount $file $file -pagesobject $p -fsindexobject $i]
    string equal [$h getindex] $i
} -cleanup {
    cookfs::Unmount $file
} -result 1

test cookfsVfs-1.7 "Setting metadata on mount" -setup {
    set file [makeFile {} cookfs.cfs]
    variable h
} -body {
    cookfs::Mount $file $file
    makeBinFile {} testfile $file
    cookfs::Unmount $file

    set h [cookfs::Mount $file $file -setmetadata {test1 1 test2 2}]
    cookfs::Unmount $file

    set h [cookfs::Mount $file $file]
    assertEq [$h getmetadata test1] 1
    assertEq [$h getmetadata test2] 2
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-1.8.1 "Mounting as volume, unmount with vfs::unmount" -constraints {packageTclvfs enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    variable h
} -body {
    cookfs::Mount $file $file -compression none
    makeBinFile {} testfile $file
    cookfs::Unmount $file

    set h [cookfs::Mount $file test:/ -volume]
    assertGe [lsearch -exact [file volumes] test:/] 0
    # don't change this to cookfs::Unmount. Here we test vfs::unmount
    vfs::unmount test:/
} -cleanup {
    catch { vfs::unmount $file }
    catch { vfs::unmount test:/ }
} -ok

test cookfsVfs-1.8.2 "Mounting as volume, unmount with cookfs::Unmount" -setup {
    set file [makeFile {} cookfs.cfs]
    variable h
} -body {
    cookfs::Mount $file $file -compression none
    makeBinFile {TEST} testfile $file
    cookfs::Unmount $file

    set h [cookfs::Mount $file test:/ -volume]
    assertGe [lsearch -exact [file volumes] test:/] 0
    cookfs::Unmount test:/
} -cleanup {
    catch { cookfs::Unmount $file }
    catch { cookfs::Unmount test:/ }
} -ok

test cookfsVfs-1.8.3 "Mounting multiple volumes, unmounting a single volume" -setup {
    set file [makeFile {} cookfs.cfs]
} -body {
    cookfs::Mount $file $file -compression none
    makeBinFile {TEST} testfile $file
    cookfs::Unmount $file

    cookfs::Mount $file test1:/ -volume
    cookfs::Mount $file test2:/ -volume
    cookfs::Mount $file test3:/ -volume

    assertGe [lsearch -exact [file volumes] test1:/] 0
    assertGe [lsearch -exact [file volumes] test2:/] 0
    assertGe [lsearch -exact [file volumes] test3:/] 0

    cookfs::Unmount test2:/

    assertGe [lsearch -exact [file volumes] test1:/] 0
    assertEq [lsearch -exact [file volumes] test2:/] -1
    assertGe [lsearch -exact [file volumes] test3:/] 0

    cookfs::Unmount test1:/

    assertEq [lsearch -exact [file volumes] test1:/] -1
    assertEq [lsearch -exact [file volumes] test2:/] -1
    assertGe [lsearch -exact [file volumes] test3:/] 0

    cookfs::Unmount test3:/

    assertEq [lsearch -exact [file volumes] test1:/] -1
    assertEq [lsearch -exact [file volumes] test2:/] -1
    assertEq [lsearch -exact [file volumes] test3:/] -1
} -cleanup {
    catch {cookfs::Unmount $file}
    catch {cookfs::Unmount test1:/}
    catch {cookfs::Unmount test2:/}
    catch {cookfs::Unmount test3:/}
} -ok

test cookfsVfs-1.8.4.1.1 "Mounting as volume, glob results, -directory" -setup {
    set img [makeFile {} cookfs.cfs]
    set mnt "test:/"
} -body {
    cookfs::Mount $img $mnt -compression none -volume
    makeBinFile {} testfile $mnt
    # TODO: it is a hack to pass temporary Tcl object as an argument
    # for the -directory parameter to avoid memory leak report.
    # See TODO item for details.
    glob -directory [string range $mnt 0 end] *
} -cleanup {
    cookfs::Unmount $mnt
} -result {test:/testfile}

test cookfsVfs-1.8.4.1.2 "Mounting as volume, glob results, -tails -directory" -setup {
    set img [makeFile {} cookfs.cfs]
    set mnt "test:/"
} -body {
    cookfs::Mount $img $mnt -compression none -volume
    makeBinFile {} testfile $mnt
    # TODO: it is a hack to pass temporary Tcl object as an argument
    # for the -directory parameter to avoid memory leak report.
    # See TODO item for details.
    glob -directory [string range $mnt 0 end] -tails *
} -cleanup {
    cookfs::Unmount $mnt
} -result {testfile}

test cookfsVfs-1.8.4.2.1 "Mounting as volume, glob results, -path" -setup {
    set img [makeFile {} cookfs.cfs]
    set mnt "test:/"
} -body {
    cookfs::Mount $img $mnt -compression none -volume
    makeBinFile {} testfile $mnt
    glob -path "${mnt}test" *
} -cleanup {
    cookfs::Unmount $mnt
} -result {test:/testfile}

test cookfsVfs-1.8.4.2.2 "Mounting as volume, glob results, -tails -path" -setup {
    set img [makeFile {} cookfs.cfs]
    set mnt "test:/"
} -body {
    cookfs::Mount $img $mnt -compression none -volume
    makeBinFile {} testfile $mnt
    glob -path "${mnt}test" -tails *
} -cleanup {
    cookfs::Unmount $mnt
} -result {testfile}

test cookfsVfs-1.9 "Test storing same files" -constraints {enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    variable h
} -body {
    cookfs::Mount $file $file -smallfilesize 40960
    makeFile [string repeat "TEST"    64] [file join $file test1a]
    makeFile [string repeat "TEST"  1024] [file join $file test2a]
    makeFile [string repeat "TEST"    64] [file join $file test1b]
    makeFile [string repeat "TEST" 16384] [file join $file test4a]
    makeFile [string repeat "TEST"  4096] [file join $file test3a]
    makeFile [string repeat "TEST"  1024] [file join $file test2b]
    makeFile [string repeat "TEST"  4096] [file join $file test3b]
    makeFile [string repeat "TEST" 16384] [file join $file test4b]
    cookfs::Unmount $file

    set h [cookfs::Mount $file $file -readonly]
    assertTrue [fsindexEqual [[$h getindex] get test4a] [[$h getindex] get test4b]]
    assertTrue [fsindexEqual [[$h getindex] get test3a] [[$h getindex] get test3b]]
    assertTrue [fsindexEqual [[$h getindex] get test2a] [[$h getindex] get test2b]]
    assertTrue [fsindexEqual [[$h getindex] get test1a] [[$h getindex] get test1b]]
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-2.1 "Test compressing entire directory structure" -setup {
    set dir [makeDirectory cookfs.vfs]
    makeSimpleTree $dir
    set file [makeFile {} cookfs.cfs]
} -body {
    cookfs::Mount $file $file
    file copy -force $dir [file join $file vfs]
    testIfEqual $dir [file join $file vfs]
} -cleanup {
    cookfs::Unmount $file
} -result 1

test cookfsVfs-2.2 "Test compressing entire directory structure after remount" -setup {
    set dir [makeDirectory cookfs.vfs]
    makeSimpleTree $dir
    set file [makeFile {} cookfs.cfs]
} -body {
    cookfs::Mount $file $file
    file copy -force $dir [file join $file vfs]
    cookfs::Unmount $file
    cookfs::Mount $file $file
    testIfEqual $dir [file join $file vfs]
} -cleanup {
    cookfs::Unmount $file
} -result 1

test cookfsVfs-2.3 "Test correct storing of empty files or new directory as only change in existing cookfs" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
    makeBinFile [string repeat TEST 1024] file1 $file
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount $file $file]
    # create 2 files so length of new index is not smaller than previously
    makeBinFile {} file2 $file
    makeBinFile {} file34 $file
    cookfs::Unmount $file

    set fsid [cookfs::Mount $file $file]
    assertTrue [file exists $file/file2] "Unable to find file2 in archive"
    # create 2 directories so length of new index is not smaller than previously
    file mkdir $file/dir1
    file mkdir $file/dir23
    cookfs::Unmount $file

    set fsid [cookfs::Mount $file $file]
    assertTrue [file exists $file/dir1] "Unable to find dir1 in archive"
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-3.1 "Test creating files in non-existant directory in VFS" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
} -body {
    close [open $file/somedir/file w]
} -cleanup {
    cookfs::Unmount $file
} -match glob -error "*no such file or directory*"

test cookfsVfs-3.2 "Test creating files in file in VFS" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
} -body {
    close [open $file/file w]
    close [open $file/file/otherfile w]
} -cleanup {
    cookfs::Unmount $file
} -match glob -error "*not a directory*"

test cookfsVfs-3.3.1 "Test creating directories in file in VFS" -constraints tcl86 -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
} -body {
    close [open $file/file w]
    file mkdir $file/file/somedir
} -cleanup {
    cookfs::Unmount $file
} -match glob -error "*file already exists*"

test cookfsVfs-3.3.2 "Test creating directories in file in VFS" -constraints tcl90 -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
} -body {
    close [open $file/file w]
    file mkdir $file/file/somedir
} -cleanup {
    cookfs::Unmount $file
} -match glob -error "*file exists*"

test cookfsVfs-3.4 "Test creating directories and files" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
} -body {
    file mkdir $file/dir1
    file mkdir $file/dir2
    file mkdir $file/dir2/dir3
    close [open $file/file2 w]
    close [open $file/dir2/file4 w]
    close [open $file/dir2/dir3/file5 w]
    cookfs::Unmount $file
    set fsid [cookfs::Mount $file $file]
    assertEq [lsort [glob -tails -directory $file * */* */*/*]] \
        {dir1 dir2 dir2/dir3 dir2/dir3/file5 dir2/file4 file2}
    assertEq [lsort [glob -tails -directory $file -type d -nocomplain * */* */*/*]] \
        {dir1 dir2 dir2/dir3}
    assertEq [lsort [glob -tails -directory $file -type f -nocomplain * */* */*/*]] \
        {dir2/dir3/file5 dir2/file4 file2}
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-4.2 "Test add-aside feature using fsid aside command" -constraints cookfsAside -setup {
    set file [makeFile {} cookfs.cfs]
    set file2 [makeFile {} cookfs2.cfs]
    set fsid [cookfs::Mount $file $file]
    close [open $file/file1 w]
    file mkdir $file/dir1
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount -readonly $file $file]
    $fsid aside $file2
    file mkdir $file/dir2
    close [open $file/file2 w]
    cookfs::Unmount $file

    set fsid [cookfs::Mount -readonly $file $file]
    $fsid aside $file2
    lsort [glob -directory $file -tails *]
} -cleanup {
    cookfs::Unmount $file
} -result {dir1 dir2 file1 file2}

test cookfsVfs-4.4 "Test write to memory feature using fsid writetomemory command" -constraints cookfsAside -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
    close [open $file/file1 w]
    file mkdir $file/dir1
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount -readonly $file $file]
    $fsid writetomemory
    file mkdir $file/dir2
    close [open $file/file2 w]
    cookfs::Unmount $file

    set fsid [cookfs::Mount -readonly $file $file]
    lsort [glob -directory $file -tails *]
} -cleanup {
    cookfs::Unmount $file
} -result {dir1 file1}

test cookfsVfs-5.1 "Test getting metadata using fsid getmetadata command without default value" -constraints cookfsMetadata -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount -readonly $file $file]
    $fsid getmetadata nonexistant
} -cleanup {
    cookfs::Unmount $file
} -error {Parameter not defined}

test cookfsVfs-5.2 "Test getting metadata using fsid getmetadata command with default value" -constraints cookfsMetadata -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount -readonly $file $file]
    $fsid getmetadata nonexistant 12
} -cleanup {
    cookfs::Unmount $file
} -result {12}

test cookfsVfs-5.3 "Test setting metadata using fsid setmetadata command" -constraints cookfsMetadata -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
} -body {
    $fsid setmetadata somename othervalue
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-5.4 "Test setting metadata in a read-only mount" -constraints cookfsMetadata -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount -readonly $file $file]
    $fsid setmetadata somename othervalue
} -cleanup {
    cookfs::Unmount $file
} -error {Archive is read-only}

test cookfsVfs-5.5 "Test setting and getting metadata" -constraints cookfsMetadata -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file]
    $fsid setmetadata somename othervalue
    cookfs::Unmount $file
} -body {
    set fsid [cookfs::Mount -readonly $file $file]
    $fsid getmetadata somename
} -cleanup {
    cookfs::Unmount $file
} -result {othervalue}

test cookfsVfs-6.1 "Test crc32 based VFS and page handling" -constraints {cookfsMetadata enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    variable h
} -body {
    cookfs::Mount -pagehash crc32 $file $file
    makeBinFile {TEST TEST} test1 $file
    cookfs::Unmount $file

    cookfs::Mount $file $file
    makeBinFile {TEST TEST} test2 $file
    cookfs::Unmount $file

    set h [cookfs::Mount $file $file -readonly]
    [$h getpages] length
} -cleanup {
    cookfs::Unmount $file
} -result {1}

test cookfsVfs-7.1 "Test filesize command" -setup {
    set file [makeBinFile [string repeat "TEST" 1024] pages.cfs]
    set fsid [cookfs::Mount -smallfilesize 8192 -compression none $file $file]
} -body {
    makeBinFile [string repeat "Test0001" 4096] testfile1 $file
    makeBinFile [string repeat "Test0002" 4096] testfile2 $file
    $fsid filesize
} -cleanup {
    cookfs::Unmount $file
} -result 69647

test cookfsVfs-7.2 "Test smallfilebuffersize command" -setup {
    set file [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount -smallfilesize 8192 -compression none $file $file]
} -body {
    makeBinFile [string repeat "Test0001" 4096] testfile1 $file
    makeBinFile [string repeat "Test0002" 4096] testfile2 $file
    makeBinFile [string repeat "Test0002" 128] testfile3 $file
    $fsid smallfilebuffersize
} -cleanup {
    cookfs::Unmount $file
} -result 1024

test cookfsVfs-8.1 "Test modifying file mtime" -setup {
    set file [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount -compression none $file $file]
} -body {
    makeBinFile [string repeat "Test0001" 4096] testfile1 $file
    file mtime [file join $file testfile1] 1
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    assertEq [file mtime [file join $file testfile1]] 1 "Invalid mtime after first pass"
    file mtime [file join $file testfile1] 1342177280
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    file mtime [file join $file testfile1]
} -cleanup {
    cookfs::Unmount $file
} -result 1342177280

test cookfsVfs-9.1 "Test deleting files" -setup {
    set file [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount -compression none $file $file]
} -body {
    close [open [file join $file testfile1] w]
    close [open [file join $file testfile2] w]
    file mkdir [file join $file testdir1]
    file mkdir [file join $file testdir2]
    close [open [file join $file testdir2/testfile3] w]
    close [open [file join $file testdir2/testfile4] w]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    file delete -force [file join $file testfile1]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    join [lsort [glob -tails -directory $file * */*]] ,
} -cleanup {
    cookfs::Unmount $file
} -result {testdir1,testdir2,testdir2/testfile3,testdir2/testfile4,testfile2}

test cookfsVfs-9.2 "Test deleting empty directories" -setup {
    set file [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount -compression none $file $file]
} -body {
    close [open [file join $file testfile1] w]
    close [open [file join $file testfile2] w]
    file mkdir [file join $file testdir1]
    file mkdir [file join $file testdir2]
    close [open [file join $file testdir2 testfile3] w]
    close [open [file join $file testdir2 testfile4] w]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    file delete -force [file join $file testdir1]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    join [lsort [glob -tails -directory $file * */*]] ,
} -cleanup {
    cookfs::Unmount $file
} -result {testdir2,testdir2/testfile3,testdir2/testfile4,testfile1,testfile2}

test cookfsVfs-9.3 "Test deleting non-empty directories" -setup {
    set file [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount -compression none $file $file]
} -body {
    close [open [file join $file testfile1] w]
    close [open [file join $file testfile2] w]
    file mkdir [file join $file testdir1]
    file mkdir [file join $file testdir2]
    close [open [file join $file testdir2 estfile3] w]
    close [open [file join $file testdir2 testfile4] w]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    file delete -force [file join $file testdir2]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    join [lsort [glob -tails -directory $file * */*]] ,
} -cleanup {
    cookfs::Unmount $file
} -result {testdir1,testfile1,testfile2}

test cookfsVfs-9.4 "Test deleting non-empty directories with complex structure" -setup {
    set file [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount -compression none $file $file]
} -body {
    close [open [file join $file testfile1] w]
    close [open [file join $file testfile2] w]
    file mkdir [file join $file testdir1]
    file mkdir [file join $file testdir2]
    file mkdir [file join $file testdir2 testdir3]
    file mkdir [file join $file testdir2 testdir3 testdir4]
    close [open [file join $file testdir2 testfile3] w]
    close [open [file join $file testdir2 testfile4] w]
    close [open [file join $file testdir2 testdir3 testfile5] w]
    close [open [file join $file testdir2 testdir3 testfile6] w]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    file delete -force [file join $file testdir2]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -compression none $file $file]
    join [lsort [glob -tails -directory $file * */*]] ,
} -cleanup {
    cookfs::Unmount $file
} -result {testdir1,testfile1,testfile2}

test cookfsVfs-10.1.1 "Test changing compression without remounting, with custom compression" -constraints {
    enabledTclCmds enabledTclCallbacks
} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fc
    variable idx
    set fsid [cookfs::Mount $file $file -compression custom -smallfilesize 32768 \
        -compresscommand testcompressraw -decompresscommand testdecompressraw -alwayscompress]
} -body {
    $fsid compression zlib
    assertEq [$fsid compression] "zlib" "Getting compression does not return 'zlib'"

    makeBinFile [string repeat "TEST" 256] testfile1 $file

    $fsid compression none
    assertEq [$fsid compression] "none" "Getting compression does not return 'none'"

    makeBinFile [string repeat "test" 256] testfile2 $file

    $fsid compression custom
    assertEq [$fsid compression] "custom" "Getting compression does not return 'custom'"
    cookfs::Unmount $file

    set fsid [cookfs::Mount $file $file -readonly \
        -compresscommand testcompressraw -decompresscommand testdecompressraw -alwayscompress]
    set idx [[$fsid getpages] index]
    cookfs::Unmount $file

    set fc [viewBinFile $file]

    assertNotContain $fc [string repeat "TEST" 256] "File testfile1 should be compressed"
    assertContain $fc [string repeat "test" 256] "File testfile2 should not be compressed"
    assertContain $fc [testcompressraw $idx] "Index not found"
} -cleanup {
    catch { cookfs::Unmount $file }
    testrawcleanup
} -ok

test cookfsVfs-10.1.2 "Test changing compression without remounting, with custom compression" -constraints {
    enabledTclCmds enabledCPages
} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fc
    variable idx
    set fsid [cookfs::Mount $file $file -compression lzma -smallfilesize 32768 -alwayscompress]
} -body {
    $fsid compression zlib
    assertEq [$fsid compression] "zlib" "Getting compression does not return 'zlib'"

    makeBinFile [string repeat "TEST" 256] testfile1 $file

    $fsid compression none
    assertEq [$fsid compression] "none" "Getting compression does not return 'none'"

    makeBinFile [string repeat "test" 256] testfile2 $file

    $fsid compression lzma
    assertEq [$fsid compression] "lzma" "Getting compression does not return 'lzma'"
    cookfs::Unmount $file

    set fc [viewBinFile $file]

    assertNotContain $fc [string repeat "TEST" 256] "File testfile1 should be compressed"
    assertContain $fc [string repeat "test" 256] "File testfile2 should not be compressed"
} -cleanup {
    catch { cookfs::Unmount $file }
    testrawcleanup
} -ok

test cookfsVfs-11.1 "Test unmount using fsid" -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    cookfs::Unmount $fsid
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { cookfs::Unmount $file }
} -ok

test cookfsVfs-11.2 "Test unmount using mount point" -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    cookfs::Unmount $file
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { cookfs::Unmount $file }
} -ok

test cookfsVfs-11.3 "Test unmount using mount point (relative)" -setup {
    set file pages.cfs
    # make sure no additional data is written to file
    close [open $file w]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    cookfs::Unmount $file
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { cookfs::Unmount $file }
    file delete $file
} -ok

test cookfsVfs-11.4 "Test unmount using vfs::unmount" -constraints {packageTclvfs enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [vfs::cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    vfs::unmount $file
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { vfs::unmount $file }
} -ok

test cookfsVfs-12.1 "Test registration in tclvfs, should be registered by default" -constraints {packageTclvfs enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [vfs::cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    # Don't change this to cookfs::Unmount. This test checks vfs::unmount command.
    # vfs::unmount should unmount cookfs successfully.
    vfs::unmount $file
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { vfs::unmount $file }
} -ok

# Run this test with c-vfs only, as tcl-vfs will not work if cookfs is not registered with tclvfs.
test cookfsVfs-12.2 "Test registration in tclvfs, should not be registered due to -noregister" -constraints { enabledCVfs packageTclvfs enabledTclCmds } -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [vfs::cookfs::Mount -noregister $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    # this should fail
    assertErrMsgMatch { vfs::unmount $file } {can't read "_unmountCmd(*)": no such element in array}
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    # this has to be successful
    cookfs::Unmount $fsid
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { cookfs::Unmount $fsid }
} -ok

test cookfsVfs-12.3 "Test that cookfs::Unmount invoked with fsid unregister cookfs in tclvfs" -constraints { packageTclvfs enabledTclCmds } -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [vfs::cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    # this has to be successful
    cookfs::Unmount $fsid
    assertEq [file type $file] "file"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 0
    # this should fail with:
    # can't read "_unmountCmd(/w/projects/build/_cookfs/_tmp/pages.cfs)": no such element in array
    # because cookfs::Unmount unregistered cookfs from tclvfs
    assertErrMsgMatch { vfs::unmount $file } {can't read "_unmountCmd(*)": no such element in array}
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
} -cleanup {
    catch { cookfs::Unmount $fsid }
} -ok

test cookfsVfs-12.4 "Test that cookfs::Unmount invoked with mount path unregister cookfs in tclvfs" -constraints { packageTclvfs enabledTclCmds } -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    assertEq [file type $file] "file"
    set fsid [vfs::cookfs::Mount $file $file]
    assertEq [file type $file] "directory"
    # ensure that mount handler command exists
    assertEq [llength [info commands $fsid]] 1
    # this has to be successful
    cookfs::Unmount $file
    assertEq [file type $file] "file"
    # ensure that mount handler command deleted
    assertEq [llength [info commands $fsid]] 0
    # this should fail with:
    # can't read "_unmountCmd(/w/projects/build/_cookfs/_tmp/pages.cfs)": no such element in array
    # because cookfs::Unmount unregistered cookfs from tclvfs
    assertErrMsgMatch { vfs::unmount $file } {can't read "_unmountCmd(*)": no such element in array}
    assertEq [file type $file] "file"
} -cleanup {
    catch { cookfs::Unmount $fsid }
} -ok

test cookfsVfs-13.1 "Test -bootstrap option for cookfs::Mount, when opening new archive" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    set bootstrap "TEST BOOTSTRAP"
    variable fsid
} -body {
    set fsid [cookfs::Mount -bootstrap $bootstrap $file $file]
    cookfs::Unmount $file
    set fsid [cookfs::Mount $file $file -readonly]
    assertEq [[$fsid getpages] get 0] $bootstrap
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-13.2 "Test -bootstrap option for cookfs::Mount is ignored, when opening existing archive" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    set bootstrap "TEST BOOTSTRAP"
    variable fsid
} -body {
    set fsid [cookfs::Mount -bootstrap $bootstrap $file $file]
    cookfs::Unmount $file
    set fsid [cookfs::Mount -bootstrap "XXXX" $file $file]
    assertEq [[$fsid getpages] get 0] $bootstrap
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-13.3 "Test -bootstrap option for cookfs::Mount, ignore empty bootstrap" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    set fsid [cookfs::Mount -bootstrap "" $file $file]
    [$fsid getpages] length
} -cleanup {
    cookfs::Unmount $file
} -result 0

test cookfsVfs-14.1 "Test -pagehash option for cookfs::Mount, when opening new archive (md5)" -constraints { enabledCPages enabledTclCmds } -setup {
    set file [makeBinFile {} pages.cfs]
    set hash "md5"
    variable fsid
} -body {
    set fsid [cookfs::Mount -pagehash $hash $file $file]
    assertEq [[$fsid getpages] hash] $hash
    assertEq [[$fsid getindex] getmetadata cookfs.pagehash] $hash
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-14.2 "Test -pagehash option for cookfs::Mount, when opening new archive (crc32)" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    set hash "crc32"
    variable fsid
} -body {
    set fsid [cookfs::Mount -pagehash $hash $file $file]
    assertEq [[$fsid getpages] hash] $hash
    assertEq [[$fsid getindex] getmetadata cookfs.pagehash] $hash
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-14.3 "Test -pagehash option for cookfs::Mount, when reopening (md5)" -constraints { enabledCPages enabledTclCmds } -setup {
    set file [makeBinFile {} pages.cfs]
    set hash "md5"
    variable fsid
} -body {
    cookfs::Mount -pagehash $hash $file $file
    # make sure that archive is not empty, so hash algo will not reset after reopen
    makeFile {} temp1 $file
    cookfs::Unmount $file
    set fsid [cookfs::Mount $file $file]
    assertEq [[$fsid getpages] hash] $hash
    assertEq [[$fsid getindex] getmetadata cookfs.pagehash] $hash
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-14.4 "Test -pagehash option for cookfs::Mount, when reopening (crc32)" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    set hash "crc32"
    variable fsid
} -body {
    cookfs::Mount -pagehash $hash $file $file
    # make sure that archive is not empty, so hash algo will not reset after reopen
    makeFile {} temp1 $file
    cookfs::Unmount $file
    set fsid [cookfs::Mount $file $file]
    assertEq [[$fsid getpages] hash] $hash
    assertEq [[$fsid getindex] getmetadata cookfs.pagehash] $hash
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-14.5 "Test -pagehash option for cookfs::Mount is ignored, when opening existing archive" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    set hash "crc32"
    variable fsid
} -body {
    cookfs::Mount -pagehash $hash $file $file
    # make sure that archive is not empty
    makeFile {} temp1 $file
    cookfs::Unmount $file
    set fsid [cookfs::Mount -pagehash "md5" $file $file]
    assertEq [[$fsid getpages] hash] $hash
    assertEq [[$fsid getindex] getmetadata cookfs.pagehash] $hash
} -cleanup {
    cookfs::Unmount $file
} -ok

# Here we just check if "<fsindex> getmetadata cookfs.pagehash" ends with an error.
# Actual values are not interested.
test cookfsVfs-14.6 "Test that cookfs.pagehash metadata exists by default" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    set fsid [cookfs::Mount $file $file]
    [$fsid getindex] getmetadata cookfs.pagehash
    # make sure that archive is not empty
    makeFile {} temp1 $file
    cookfs::Unmount $file
    set fsid [cookfs::Mount $file $file]
    [$fsid getindex] getmetadata cookfs.pagehash
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-14.7 "Test that cookfs.pagehash metadata matches actual pages hash" -constraints {enabledTclCmds} -setup {
    set file [makeBinFile {} pages.cfs]
    variable fsid
} -body {
    set fsid [cookfs::Mount $file $file]
    assertEq [[$fsid getpages] hash] [[$fsid getindex] getmetadata cookfs.pagehash]
    # make sure that archive is not empty
    makeFile {} temp1 $file
    cookfs::Unmount $file
    set fsid [cookfs::Mount $file $file]
    assertEq [[$fsid getpages] hash] [[$fsid getindex] getmetadata cookfs.pagehash]
} -cleanup {
    cookfs::Unmount $file
} -ok

test cookfsVfs-14.8 "Test unknown hash value" -setup {
    set file [makeBinFile {} pages.cfs]
} -body {
    set fsid [cookfs::Mount -pagehash foo $file $file]
} -cleanup {
    catch { cookfs::Unmount $file }
} -error {bad hash "foo": must be md5 or crc32}

test cookfsVfs-15.1 "Test optimizelist with empty base" -constraints {enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none \
        -smallfilesize 0x10 -smallfilebuffer 0x30 -pagesize 0x10]
    makeSimpleTree2 $file
    makeSimpleTree2 $file/subtree1
    makeBinFile "ABCD" diff $file/subtree1
    cookfs::Unmount $file
    variable h
    variable files
} -body {
    set h [cookfs::Mount $file $file]
    set files [$h optimizelist "" [getFilesRelative $file]]
    # Verify the result.
    join [testOptimizedList "" $files [$h getindex]] \n
} -cleanup {
    cookfs::Unmount $file
} -result {}

test cookfsVfs-15.2 "Test optimizelist with non-empty base" -constraints {enabledTclCmds} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none \
        -smallfilesize 0x10 -smallfilebuffer 0x30 -pagesize 0x10]
    makeSimpleTree2 $file
    makeSimpleTree2 $file/subtree1
    makeBinFile "ABCD" diff $file/subtree1
    cookfs::Unmount $file
    variable h
    variable files
} -body {
    set h [cookfs::Mount $file $file]
    set files [$h optimizelist "subtree1" [getFilesRelative $file/subtree1]]
    # Verify the result.
    join [testOptimizedList "subtree1" $files [$h getindex]] \n
} -cleanup {
    cookfs::Unmount $file
} -result {}

# Attributes will work only for c-vfs

test cookfsVfs-16.1.1 "Test set attributes for root" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
} -body {
    file attributes $file -vfs 2
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-vfs" is read-only}

test cookfsVfs-16.1.2 "Test list attributes for root" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
} -body {
    lsort [dict keys [file attributes $file]]
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result {-fileset -handle -metadata -pages -vfs}

test cookfsVfs-16.1.3 "Test get attributes for root" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
} -body {
    assertEq [file attributes $file -vfs] 1
    assertEq [file attributes $file -handle] $fsid
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-16.1.4 "Test get unknown attribute for root" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
} -body {
    file attributes $file -foo
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -error {bad option "-foo": must be -vfs, -handle, -pages, -metadata, or -fileset}

test cookfsVfs-16.1.5 "Test -handle attribute for root when vfs created with -nocommand" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none -nocommand]
} -body {
    file attributes $file -handle
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result {}

test cookfsVfs-16.2.1 "Test set attributes for file" -constraints {enabledCVfs} -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set file2 [makeBinFile "" test $file]
} -body {
    file attributes $file2 -vfs 2
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -error {attribute "-vfs" is read-only}

test cookfsVfs-16.2.2 "Test list attributes for file" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set file2 [makeBinFile "" test $file]
} -body {
    lsort [dict keys [file attributes $file2]]
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result {-vfs}

test cookfsVfs-16.2.3 "Test get attributes for file" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set file2 [makeBinFile "" test $file]
} -body {
    assertEq [file attributes $file2 -vfs] 1
    assertErrMsg { file attributes $file2 -handle } {bad option "-handle": must be -vfs}
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-16.2.4 "Test get unknown attribute for file" -setup {
    set file [makeFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none]
    set file2 [makeBinFile "" test $file]
} -body {
    file attributes $file2 -foo
} -cleanup {
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -error {bad option "-foo": must be -vfs}

test cookfsVfs-17.1 "Test in-memory vfs, open with a file" -setup {
    set dir [makeDirectory cookfs.vfs]
    makeSimpleTree2 $dir
    set file [makeBinFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -writetomemory \
        -smallfilesize 0x10 -smallfilebuffer 0x30 -pagesize 0x10]
} -body {
    file copy -force $dir [file join $file vfs]
    assertTrue [testIfEqual $dir [file join $file vfs]]
    cookfs::Unmount $file
    assertEq [file size $file] 0
} -cleanup {
    catch { cookfs::Unmount $file }
} -ok

test cookfsVfs-17.2 "Test in-memory vfs, open without a file" -setup {
    set dir [makeDirectory cookfs.vfs]
    makeSimpleTree2 $dir
    set mnt "/mountpoint"
    set fsid [cookfs::Mount $mnt -writetomemory \
        -smallfilesize 0x10 -smallfilebuffer 0x30 -pagesize 0x10]
} -body {
    file copy -force $dir [file join $mnt vfs]
    assertTrue [testIfEqual $dir [file join $mnt vfs]]
    cookfs::Unmount $mnt
} -cleanup {
    catch { cookfs::Unmount $mnt }
} -ok

test cookfsVfs-17.3 "Test in-memory vfs, open existing archive" -setup {
    set dir [makeDirectory cookfs.vfs]
    makeSimpleTree2 $dir
    set file [makeBinFile {} cookfs.cfs]
    set fsid [cookfs::Mount $file $file -compression none \
        -smallfilesize 0x10 -smallfilebuffer 0x30 -pagesize 0x10]
    file copy -force $dir [file join $file vfs]
    cookfs::Unmount $file
    set file2 [makeBinFile {} cookfs2.cfs]
    file copy -force $file $file2
} -body {
    set fsid [cookfs::Mount $file $file -writetomemory \
        -smallfilesize 0x10 -smallfilebuffer 0x30 -pagesize 0x10]
    assertTrue [testIfEqual $dir [file join $file vfs]]
    makeSimpleTree2 $file/subdirX
    cookfs::Unmount $file
    # Compare archive $file with its copy $file2 to make sure it hasn't changed.
    assertTrue [testIfEqual $file $file2]
} -cleanup {
    catch { cookfs::Unmount $file }
} -ok

test cookfsVfs-18.1 "Test that fsindex/pages are available when their\
     commands are deleted, but they are bound to existing VFS" -constraints {enabledTclCmds enabledCVfs} -setup {
    set file [makeBinFile {} cookfs.cfs]
    variable p
    variable i
    variable file2
} -body {
    set p [cookfs::pages -compression none $file]
    set i [cookfs::fsindex]
    cookfs::Mount $file $file -pagesobject $p -fsindexobject $i
    # delete pages/index commands
    rename $p ""
    rename $i ""
    # try to add a file
    set file2 [makeBinFile TEST01 test $file]
    cookfs::Unmount $file
    cookfs::Mount $file $file -readonly
    viewBinFile $file2
} -cleanup {
    cookfs::Unmount $file
} -result TEST01

test cookfsVfs-19.1 "Check if VFS is available in child interp" -setup {
    set file [makeBinFile {} cookfs.cfs]
    set i [interp create]
    interp eval $i [list set file $file]
} -body {
    cookfs::Mount $file $file -compression none
    interp eval $i [list file attributes $file -vfs]
} -cleanup {
    interp delete $i
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result 1

test cookfsVfs-19.2.1 "Check if files can be copied to VFS in the child interp (small file)" -setup {
    set file [makeBinFile {} cookfs.cfs]
    set file2 [makeBinFile {TEST01} test]
    set i [interp create]
    interp eval $i [list set file $file]
    interp eval $i [list set file2 $file]
} -body {
    cookfs::Mount $file $file -compression none -smallfilesize 1024 -smallfilebuffer 2048 -pagesize 1024
    interp eval $i [list file copy $file2 [file join $file test]]
    viewBinFile [file join $file test]
} -cleanup {
    interp delete $i
    cookfs::Unmount $file
} -result TEST01

test cookfsVfs-19.2.2 "Check if files can be copied to VFS in the child interp (big file)" -setup {
    set file [makeBinFile {} cookfs.cfs]
    set file2 [makeBinFile {TEST02} test]
    set i [interp create]
    interp eval $i [list set file $file]
    interp eval $i [list set file2 $file]
} -body {
    cookfs::Mount $file $file -compression none -smallfilesize 1 -smallfilebuffer 0 -pagesize 1024
    interp eval $i [list file copy $file2 [file join $file test]]
    viewBinFile [file join $file test]
} -cleanup {
    interp delete $i
    cookfs::Unmount $file
} -result TEST02

test cookfsVfs-19.3 "Check if mount handler is available in child interp" -constraints {enabledCVfs enabledTclCmds} -setup {
    set file [makeBinFile {} cookfs.cfs]
    set i [interp create]
    interp eval $i [list set file $file]
} -body {
    cookfs::Mount $file $file -compression none
    interp eval $i {
        [file attributes $file -handle] filesize
    }
} -cleanup {
    interp delete $i
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-19.4 "Check if pages handler is available in child interp" -constraints {enabledCVfs enabledTclCmds} -setup {
    set file [makeBinFile {} cookfs.cfs]
    set i [interp create]
    interp eval $i [list set file $file]
} -body {
    cookfs::Mount $file $file -compression none
    interp eval $i {
        [[file attributes $file -handle] getpages] length
    }
} -cleanup {
    interp delete $i
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result 0

test cookfsVfs-19.5 "Check if fsindex handler is available in child interp" -constraints {enabledCVfs enabledTclCmds} -setup {
    set file [makeBinFile {} cookfs.cfs]
    set i [interp create]
    interp eval $i [list set file $file]
} -body {
    cookfs::Mount $file $file -compression none
    interp eval $i {
        set result [[[file attributes $file -handle] getindex] get ""]
        # as "" is VFS root, we expect only one element
        # after 'get ""' - directory mtime
        expr { [string is wideinteger -strict $result] ? "ok" : $result }
    }
} -cleanup {
    interp delete $i
    cookfs::Unmount $file
    catch { ::cookfs::c::reset_cache }
} -result ok

test cookfsVfs-19.6.1 "Check mount/unmount in child interp" -setup {
    set file [makeBinFile {} cookfs.cfs]
    set i [interp create]
    interp eval $i [list set file $file]
} -body {
    interp eval $i {
        package require cookfs
        cookfs::Mount $file $file -compression none
    }
    assertEq [file type $file] "directory"
    interp eval $i {
        cookfs::Unmount $file
    }
    assertEq [file type $file] "file"
} -cleanup {
    interp delete $i
    catch { cookfs::Unmount $file }
} -ok

test cookfsVfs-19.6.2 "Check unmount in child interp after interp died" -setup {
    set file [makeBinFile {} cookfs.cfs]
    set i [interp create]
    interp eval $i [list set file $file]
} -body {
    interp eval $i {
        package require cookfs
        cookfs::Mount $file $file -compression none
    }
    assertEq [file type $file] "directory"
    interp delete $i
    assertEq [file type $file] "file"
} -cleanup {
    catch { interp delete $i }
    catch { cookfs::Unmount $file }
} -ok

# This test is related to cookfsVfs-20.1.2. If something needs to be changed here,
# the appropriate changes should be added to cookfsVfs-20.1.2.
test cookfsVfs-20.1.1 "Don't crash when stamp is not present" -setup {
    # base compression + base compression level + encryption
    set data [binary format ccc 0 0 0]
    # pgindex
    # compression + compression level + 16 bytes hash + compressed size + uncompressed size
    append data [binary format ccc16II 0 0 \
        {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0} \
        0 0]
    # fsindex
    # compression + compression level + 16 bytes hash + compressed size + uncompressed size
    append data [binary format ccc16II 0 0 \
        {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0} \
        0 0]
    append data "CFS0003"
    set file [makeBinFile $data pages.cfs]
} -body {
    cookfs::Mount $file $file -readonly
} -cleanup {
    cookfs::Unmount $file
} -ok

# This test differs from the previous one in that there is no byte representing
# the compression level in the tail of the archive
test cookfsVfs-20.1.2 "Don't crash when stamp is not present and archive suffix is malformed" -setup {
    # base compression + encryption
    set data [binary format cc 0 0]
    # pgindex
    # compression + compression level + 16 bytes hash + compressed size + uncompressed size
    append data [binary format ccc16II 0 0 \
        {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0} \
        0 0]
    # fsindex
    # compression + compression level + 16 bytes hash + compressed size + uncompressed size
    append data [binary format ccc16II 0 0 \
        {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0} \
        0 0]
    append data "CFS0003"
    set file [makeBinFile $data pages.cfs]
} -body {
    cookfs::Mount $file $file -readonly
} -cleanup {
    catch { cookfs::Unmount $file }
} -error {Unable to create Cookfs object: index not found}

test cookfsVfs-21.1 "Open a file that starts as a mount point without an error" -setup {
    set cfs [makeBinFile {} pages.cfs]
    set checkfile1 [makeFile {OUTSIDE} pages.cfs.test]
    variable checkfile2
} -body {
    cookfs::Mount $cfs $cfs -compression none
    set checkfile2 [makeFile {INSIDE} test $cfs]
    assertEq [viewFile $checkfile1] OUTSIDE
    assertEq [viewFile $checkfile2] INSIDE
} -cleanup {
    cookfs::Unmount $cfs
} -ok

test cookfsVfs-22.1.1 "Verify VFS mount point with a filesystem separator at the end" -setup {
    set cfs [makeBinFile {} pages.cfs]
    set mnt "mount:/"
} -body {
    cookfs::Mount $cfs $mnt -compression none -volume
    makeFile {INSIDE} test $mnt
    viewFile "${mnt}test"
} -cleanup {
    cookfs::Unmount $mnt
} -result {INSIDE}

test cookfsVfs-22.1.2 "Verify VFS mount point with a filesystem separator at the end (using join)" -setup {
    set cfs [makeBinFile {} pages.cfs]
    set mnt "mount:/"
} -body {
    cookfs::Mount $cfs $mnt -compression none -volume
    makeFile {INSIDE} test $mnt
    viewFile [file join $mnt "test"]
} -cleanup {
    cookfs::Unmount $mnt
} -result {INSIDE}

test cookfsVfs-22.2.1 "Verify VFS mount point with 2 filesystem separators at the end" -setup {
    set cfs [makeBinFile {} pages.cfs]
    set mnt "mount://"
} -body {
    cookfs::Mount $cfs $mnt -compression none -volume
    makeFile {INSIDE} test $mnt
    viewFile "${mnt}test"
} -cleanup {
    cookfs::Unmount $mnt
} -result {INSIDE}

test cookfsVfs-22.2.2 "Verify VFS mount point with 2 filesystem separators at the end (using join)" -setup {
    set cfs [makeBinFile {} pages.cfs]
    set mnt "mount://"
} -body {
    cookfs::Mount $cfs $mnt -compression none -volume
    makeFile {INSIDE} test $mnt
    viewFile [file join $mnt "test"]
} -cleanup {
    cookfs::Unmount $mnt
} -result {INSIDE}

test cookfsVfs-23.1.1 "Test fileset, missing argument to -fileset" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
} -body {
    cookfs::Mount $cfs $cfs -fileset
} -cleanup {
    catch { cookfs::Unmount $cfs }
} -error {missing argument to -fileset option}

test cookfsVfs-23.2.1 "Test fileset, attributes for fileset-disabled / fileset-enabled VFS" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [file attributes $cfs -fileset] {}
    file attribute $cfs -fileset foo
    assertEq [file attributes $cfs -fileset] {foo}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.3.1.1 "Test fileset, RO VFS, open non-fileset VFS with -fileset" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
    # Make sure VFS is not empty
    makeBinFile {} test $cfs
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly -fileset foo
} -cleanup {
    catch { cookfs::Unmount $cfs }
} -error {error when selecting a fileset: cannot set a fileset to a non-empty fsindex without an initialized fileset}

test cookfsVfs-23.3.1.2 "Test fileset, RO VFS, set attribute for non-fileset VFS" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
    # Make sure VFS is not empty
    makeBinFile {} test $cfs
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly
    file attributes $cfs -fileset foo
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {cannot set a fileset to a non-empty fsindex without an initialized fileset}

test cookfsVfs-23.3.2.1 "Test fileset, RO VFS, open fileset VFS with unknown -fileset" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -fileset foo
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly -fileset bar
} -cleanup {
    catch { cookfs::Unmount $cfs }
    catch { ::cookfs::c::reset_cache }
} -error {error when selecting a fileset: VFS does not have the required fileset "bar", it cannot be created due to read-only mode}

test cookfsVfs-23.3.2.2 "Test fileset, RO VFS, set wrong attribute for fileset VFS" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -fileset foo
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly
    file attributes $cfs -fileset qux
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {VFS does not have the required fileset "qux", it cannot be created due to read-only mode}

test cookfsVfs-23.3.3.1 "Test fileset, RO VFS, open fileset VFS with known -fileset" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -fileset foo
    file attributes $cfs -fileset qux
    file attributes $cfs -fileset bar
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly -fileset qux
    assertEq [lindex [file attributes $cfs -fileset] 0] qux
    lsort [file attributes $cfs -fileset]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {bar foo qux}

test cookfsVfs-23.3.3.2 "Test fileset, RO VFS, set known attribute for fileset VFS" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -fileset foo
    file attributes $cfs -fileset qux
    file attributes $cfs -fileset bar
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly
    assertEq [lindex [file attributes $cfs -fileset] 0] foo
    file attributes $cfs -fileset bar
    assertEq [lindex [file attributes $cfs -fileset] 0] bar
    lsort [file attributes $cfs -fileset]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {bar foo qux}

test cookfsVfs-23.4.1 "Test fileset, switch filesets on RW VFS" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
} -body {
    cookfs::Mount $cfs $cfs -fileset foo

    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {}
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.4.2 "Test fileset, switch filesets on RO VFS" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -fileset foo
    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs
    file attributes $cfs -fileset bar
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs
    cookfs::Unmount $cfs
} -body {

    # The 1st fileset by default: foo
    cookfs::Mount $cfs $cfs -readonly

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}

    cookfs::Unmount $cfs

    # Mount with specific fileset: bar
    cookfs::Mount $cfs $cfs -readonly -fileset bar

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.5.1 "Test fileset, aside, current fileset is preserved" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    set file2 [makeFile {} cookfs2.cfs]
    set fsid [cookfs::Mount $cfs $cfs -fileset foo]
} -body {

    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs

    file attributes $cfs -fileset bar
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs

    $fsid aside $file2

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.5.2 "Test fileset, aside, current fileset is preserved, add a file" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    set file2 [makeBinFile {} cookfs2.cfs]
    set fsid [cookfs::Mount $cfs $cfs -fileset foo]
} -body {

    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs

    file attributes $cfs -fileset bar
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs

    $fsid aside $file2
    makeBinFile {bar_test3} "bar_test3" $cfs

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2 bar_test3}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
    assertEq [viewBinFile "bar_test3" $cfs] {bar_test3}

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2 bar_test3}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
    assertEq [viewBinFile "bar_test3" $cfs] {bar_test3}

} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.5.3.1 "Test fileset, aside, RO VFS, current fileset is preserved" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    set file2 [makeBinFile {} cookfs2.cfs]
    set fsid [cookfs::Mount $cfs $cfs -fileset foo]
    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs
    file attributes $cfs -fileset bar
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs
    cookfs::Unmount $cfs
} -body {

    set fsid [cookfs::Mount $cfs $cfs -readonly]

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    $fsid aside $file2

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.5.3.2 "Test fileset, aside, RO VFS, current fileset is preserved, add a file" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    set file2 [makeBinFile {} cookfs2.cfs]
    set fsid [cookfs::Mount $cfs $cfs -fileset foo]
    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs
    file attributes $cfs -fileset bar
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs
    cookfs::Unmount $cfs
} -body {

    set fsid [cookfs::Mount $cfs $cfs -readonly -fileset bar]

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}

    $fsid aside $file2
    makeBinFile {bar_test3} "bar_test3" $cfs

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2 bar_test3}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
    assertEq [viewBinFile "bar_test3" $cfs] {bar_test3}

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2 bar_test3}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
    assertEq [viewBinFile "bar_test3" $cfs] {bar_test3}

} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.5.3.2 "Test fileset, aside, RO VFS, current fileset is preserved, add a file, add a fileset" -constraints {
    enabledCVfs
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    set file2 [makeBinFile {} cookfs2.cfs]
    set fsid [cookfs::Mount $cfs $cfs -fileset foo]
    makeBinFile {foo_test1} "foo_test1" $cfs
    makeBinFile {foo_test2} "foo_test2" $cfs
    file attributes $cfs -fileset bar
    makeBinFile {bar_test1} "bar_test1" $cfs
    makeBinFile {bar_test2} "bar_test2" $cfs
    cookfs::Unmount $cfs
} -body {

    set fsid [cookfs::Mount $cfs $cfs -readonly -fileset bar]

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}

    $fsid aside $file2
    makeBinFile {bar_test3} "bar_test3" $cfs

    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2 bar_test3}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
    assertEq [viewBinFile "bar_test3" $cfs] {bar_test3}

    file attributes $cfs -fileset qux
    makeBinFile {qux_test1} "qux_test1" $cfs
    makeBinFile {qux_test2} "qux_test2" $cfs

    file attributes $cfs -fileset foo
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {foo_test1 foo_test2}
    assertEq [viewBinFile "foo_test1" $cfs] {foo_test1}
    assertEq [viewBinFile "foo_test2" $cfs] {foo_test2}

    file attributes $cfs -fileset bar
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {bar_test1 bar_test2 bar_test3}
    assertEq [viewBinFile "bar_test1" $cfs] {bar_test1}
    assertEq [viewBinFile "bar_test2" $cfs] {bar_test2}
    assertEq [viewBinFile "bar_test3" $cfs] {bar_test3}

    file attributes $cfs -fileset qux
    assertEq [lsort [glob -tails -nocomplain -directory $cfs *]] {qux_test1 qux_test2}
    assertEq [viewBinFile "qux_test1" $cfs] {qux_test1}
    assertEq [viewBinFile "qux_test2" $cfs] {qux_test2}

} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-23.6.1 "Test fileset, open VFS with auto-fileset when platform is unknown" -constraints {
    enabledCVfs enabledCPkgconfig
} -setup {
    set cfs [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount $cfs $cfs -fileset foo]
    makeBinFile {foo_test1} "foo_test1" $cfs
    # Let's brake the VFS by setting its fileset mode to auto
    $fsid setmetadata "cookfs.fileset" "auto"
    cookfs::Unmount $cfs
} -body {
    cookfs::Mount $cfs $cfs -readonly
} -cleanup {
    catch { cookfs::Unmount $cfs }
} -error [format {error when selecting a fileset: VFS does not have the required fileset "%s", it cannot be created due to read-only mode} "[::cookfs::pkgconfig get platform].tcl[join [split [info tclver] .] {}]"]

test cookfsVfs-24.1 "Test metadata attrib, default metadata keys" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    lsort [file attributes $cfs -metadata]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {cookfs.pagehash cookfs.pagesize cookfs.smallfilebuffer cookfs.smallfilesize}

test cookfsVfs-24.2 "Test metadata attrib, get single key" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata cookfs.pagehash
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {md5}

test cookfsVfs-24.3.1 "Test metadata attrib, get single key, empty key" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata {}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {a list of 1 or 2 elements is expected as an argument to the -metadata attribute}

test cookfsVfs-24.3.2 "Test metadata attrib, get single key, too many list elements" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata {1 2 3}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {a list of 1 or 2 elements is expected as an argument to the -metadata attribute}

test cookfsVfs-24.3.3 "Test metadata attrib, get single key, unknown key" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata foo
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {could not find metadata key "foo"}

test cookfsVfs-24.3.1 "Test metadata attrib, set single key" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata [list cookfs.pagehash crc32]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {crc32}

test cookfsVfs-24.3.2 "Test metadata attrib, set single key, custom key" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata [list foo bar]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {bar}

test cookfsVfs-24.4.1 "Test metadata attrib, set single key, test after reopening" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata [list cookfs.pagesize 123]
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
    file attributes $cfs -metadata cookfs.pagesize
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {123}

test cookfsVfs-24.4.2 "Test metadata attrib, set single key, custom key, test after reopening" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -metadata [list foo bar]
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
    file attributes $cfs -metadata foo
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -result {bar}

test cookfsVfs-24.5 "Test metadata attrib, set single key, readonly VFS" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
} -body {
    file attributes $cfs -metadata [list cookfs.pagehash crc32]
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {failed to set the metadata key: VFS is in readonly mode}

test cookfsVfs-25.1.1 "Test pages attrib, unknown argument" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -pages foo
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {bad pages information type "foo": must be pgindex, fsindex, length, or list}

test cookfsVfs-25.1.2 "Test pages attrib, negative argument" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    file attributes $cfs -pages -1
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -error {bad page index "-1" was specified, there are 0 pages in total}

test cookfsVfs-25.2.1 "Test pages attrib, newly created VFS" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [dict get [file attributes $cfs] -pages] 0
    assertEq [file attributes $cfs -pages] 0
    assertEq [file attributes $cfs -pages length] 0
    assertEq [file attributes $cfs -pages list] {}
    assertEq [file attributes $cfs -pages fsindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index fsindex}
    assertEq [file attributes $cfs -pages pgindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index pgindex}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-25.2.2 "Test pages attrib, newly created VFS, some data exists, but not saved yet" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -pagesize 100
    makeBinFile {X} "file" $cfs
} -body {
    assertEq [dict get [file attributes $cfs] -pages] 0
    assertEq [file attributes $cfs -pages] 0
    assertEq [file attributes $cfs -pages length] 0
    assertEq [file attributes $cfs -pages list] {}
    assertEq [file attributes $cfs -pages fsindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index fsindex}
    assertEq [file attributes $cfs -pages pgindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index pgindex}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-25.2.3 "Test pages attrib, newly created VFS, some data exists, 10 pages saved" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -pagesize 10 -smallfilebuffer 0 -compression none
    makeBinFile [randomData 100] "file" $cfs
} -body {
    assertEq [dict get [file attributes $cfs] -pages] 10
    assertEq [file attributes $cfs -pages] 10
    assertEq [file attributes $cfs -pages length] 10
    assertEq [llength [file attributes $cfs -pages list]] 10
    assertEq [file attributes $cfs -pages fsindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index fsindex}
    assertEq [file attributes $cfs -pages pgindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index pgindex}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-25.3.1 "Test pages attrib, previously created VFS, no pages" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
} -body {
    assertEq [dict get [file attributes $cfs] -pages] 0
    assertEq [file attributes $cfs -pages] 0
    assertEq [file attributes $cfs -pages length] 0
    assertEq [llength [file attributes $cfs -pages list]] 0
    # offset 15 is a stamp
    assertEq [file attributes $cfs -pages fsindex] {offset 15 uncompsize 129 compsize 129 encrypted 0 compression none index fsindex}
    assertEq [file attributes $cfs -pages pgindex] {offset -1 uncompsize -1 compsize -1 encrypted 0 compression none index pgindex}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-25.3.2 "Test pages attrib, previously created VFS, 2 pages" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 10
    makeBinFile [randomData 20] "file" $cfs
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -readonly
} -body {
    assertEq [dict get [file attributes $cfs] -pages] 2
    assertEq [file attributes $cfs -pages] 2
    assertEq [file attributes $cfs -pages length] 2
    assertEq [file attributes $cfs -pages 0] {offset 0 uncompsize 10 compsize 10 encrypted 0 compression none index 0}
    assertEq [file attributes $cfs -pages 1] {offset 10 uncompsize 10 compsize 10 encrypted 0 compression none index 1}
    assertEq [file attributes $cfs -pages list] {{offset 0 uncompsize 10 compsize 10 encrypted 0 compression none index 0} {offset 10 uncompsize 10 compsize 10 encrypted 0 compression none index 1}}
    assertMatch [file attributes $cfs -pages pgindex] {offset 35 uncompsize * compsize * encrypted 0 compression none index pgindex}
    assertMatch [file attributes $cfs -pages fsindex] {offset * uncompsize * compsize * encrypted 0 compression none index fsindex}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-25.4 "Test pages attrib, compression and encryption" -constraints { enabledCVfs enabledTclCmds cookfsCrypto } -setup {
    set cfs [makeBinFile {} pages.cfs]
    set fsid [cookfs::Mount $cfs $cfs -compression none -pagesize 10 -alwayscompress -smallfilebuffer 0]
    # page0 no compression, no encryption
    makeBinFile [randomData 10] "page1" $cfs
    $fsid password "foo"
    # page1 no compression, encryption
    makeBinFile [randomData 10] "page1" $cfs
    # page2 zlib default compression, encryption
    $fsid compression zlib
    makeBinFile [randomData 10] "page1" $cfs
    $fsid compression zlib:2
    $fsid password ""
    # page3 zlib level 2 compression, no encryption
    makeBinFile [randomData 10] "page1" $cfs
} -body {
    assertEq [file attributes $cfs -pages 0] {offset 0 uncompsize 10 compsize 10 encrypted 0 compression none index 0}
    assertMatch [file attributes $cfs -pages 1] {offset 10 uncompsize 10 compsize * encrypted 1 compression none index 1}
    assertMatch [file attributes $cfs -pages 2] {offset * uncompsize 10 compsize * encrypted 1 compression zlib index 2}
    assertMatch [file attributes $cfs -pages 3] {offset * uncompsize 10 compsize * encrypted 0 compression zlib:2 index 3}
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.1 "Test attribute -metadata, cookfs.pagesize, exists by default" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertGe [file attributes $cfs -metadata cookfs.pagesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.2 "Test attribute -metadata, cookfs.pagesize, has expected value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 123
} -body {
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 123
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.3 "Test attribute -metadata, cookfs.pagesize, has expected value after remount" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 123
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 123
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.4 "Test attribute -metadata, cookfs.pagesize, has expected value after remount with a value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 123
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -pagesize 321
} -body {
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 321
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.5.1 "Test attribute -metadata, cookfs.pagesize, set wrong value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.pagesize foo]] foo
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    #assertGe [file attributes $cfs -metadata cookfs.pagesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.5.2 "Test attribute -metadata, cookfs.pagesize, set zero" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.pagesize 0]] 0
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertGe [file attributes $cfs -metadata cookfs.pagesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.5.3 "Test attribute -metadata, cookfs.pagesize, set negative" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.pagesize -2]] -2
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertGe [file attributes $cfs -metadata cookfs.pagesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-26.6 "Test attribute -metadata, cookfs.pagesize, the value is actual" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -pagesize 10
} -body {
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 10
    assertEq [file attributes $cfs -pages] 0 "make sure we have no pages"
    makeBinFile [randomData 50] "test1" $cfs
    assertEq [file attributes $cfs -pages] 5 "make sure we have 5 pages"
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -pagesize 20
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 20
    makeBinFile [randomData 40] "test2" $cfs
    assertEq [file attributes $cfs -pages] 7 "make sure we have 7 pages"
    # set a value by -metadata
    assertEq [file attributes $cfs -metadata [list cookfs.pagesize 30]] 30
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 30
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    assertEq [file attributes $cfs -metadata cookfs.pagesize] 30
    makeBinFile [randomData 90] "test3" $cfs
    assertEq [file attributes $cfs -pages] 10 "make sure we have 10 pages"
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.1 "Test attribute -metadata, cookfs.smallfilesize, exists by default" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertGe [file attributes $cfs -metadata cookfs.smallfilesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.2 "Test attribute -metadata, cookfs.smallfilesize, has expected value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilesize 123
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 123
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.3 "Test attribute -metadata, cookfs.smallfilesize, has expected value after remount" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilesize 123
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 123
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.4 "Test attribute -metadata, cookfs.smallfilesize, has expected value after remount with a value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilesize 123
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -smallfilesize 321
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 321
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.5.1 "Test attribute -metadata, cookfs.smallfilesize, set wrong value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilesize foo]] foo
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertGe [file attributes $cfs -metadata cookfs.smallfilesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.5.2 "Test attribute -metadata, cookfs.smallfilesize, set zero" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilesize 0]] 0
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.5.3 "Test attribute -metadata, cookfs.smallfilesize, set negative" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilesize -2]] -2
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertGe [file attributes $cfs -metadata cookfs.smallfilesize] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-27.6 "Test attribute -metadata, cookfs.smallfilesize, the value is actual" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilesize 10 -smallfilebuffer 1000
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 10
    assertEq [file attributes $cfs -pages] 0 "make sure we have no pages"
    makeBinFile [randomData 5] "test1" $cfs
    makeBinFile [randomData 11] "test2" $cfs
    makeBinFile [randomData 5] "test3" $cfs
    makeBinFile [randomData 11] "test4" $cfs
    assertEq [file attributes $cfs -pages] 2 "make sure we have 2 pages"
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -smallfilesize 20
    assertEq [file attributes $cfs -pages] 3 "make sure we have 3 pages"
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 20
    makeBinFile [randomData 11] "test5" $cfs
    makeBinFile [randomData 21] "test6" $cfs
    assertEq [file attributes $cfs -pages] 4 "make sure we have 4 pages"
    # set a value by -metadata
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilesize 30]] 30
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 30
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    assertEq [file attributes $cfs -pages] 5 "make sure we have 5 pages"
    assertEq [file attributes $cfs -metadata cookfs.smallfilesize] 30
    makeBinFile [randomData 11] "test7" $cfs
    makeBinFile [randomData 31] "test8" $cfs
    makeBinFile [randomData 31] "test9" $cfs
    assertEq [file attributes $cfs -pages] 7 "make sure we have 7 pages"
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    assertEq [file attributes $cfs -pages] 8 "make sure we have 8 pages"
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.1 "Test attribute -metadata, cookfs.smallfilebuffer, exists by default" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertGe [file attributes $cfs -metadata cookfs.smallfilebuffer] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.2 "Test attribute -metadata, cookfs.smallfilebuffer, has expected value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilebuffer 123
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 123
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.3 "Test attribute -metadata, cookfs.smallfilebuffer, has expected value after remount" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilebuffer 123
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 123
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.4 "Test attribute -metadata, cookfs.smallfilebuffer, has expected value after remount with a value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilebuffer 123
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -smallfilebuffer 321
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 321
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.5.1 "Test attribute -metadata, cookfs.smallfilebuffer, set wrong value" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilebuffer foo]] foo
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertGe [file attributes $cfs -metadata cookfs.smallfilebuffer] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.5.2 "Test attribute -metadata, cookfs.smallfilebuffer, set zero" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilebuffer 0]] 0
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.5.3 "Test attribute -metadata, cookfs.smallfilebuffer, set negative" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none
} -body {
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilebuffer -2]] -2
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    makeBinFile [randomData 50] "test1" $cfs
    assertGe [file attributes $cfs -metadata cookfs.smallfilebuffer] 0
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

test cookfsVfs-28.6 "Test attribute -metadata, cookfs.smallfilebuffer, the value is actual" -constraints enabledCVfs -setup {
    set cfs [makeBinFile {} pages.cfs]
    cookfs::Mount $cfs $cfs -compression none -smallfilesize 9 -smallfilebuffer 10 -pagesize 1000
} -body {
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 10
    assertEq [file attributes $cfs -pages] 0 "make sure we have no pages"
    makeBinFile [randomData 5] "test1" $cfs
    makeBinFile [randomData 5] "test2" $cfs
    makeBinFile [randomData 4] "test3" $cfs
    makeBinFile [randomData 5] "test4" $cfs
    assertEq [file attributes $cfs -pages] 1 "make sure we have 1 page"
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs -smallfilebuffer 20
    assertEq [file attributes $cfs -pages] 2 "make sure we have 2 pages"
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 20
    makeBinFile [randomData 8] "test5.1" $cfs
    makeBinFile [randomData 8] "test5.2" $cfs
    makeBinFile [randomData 8] "test5.3" $cfs
    assertEq [file attributes $cfs -pages] 3 "make sure we have 3 pages"
    # set a value by -metadata
    assertEq [file attributes $cfs -metadata [list cookfs.smallfilebuffer 30]] 30
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 30
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    assertEq [file attributes $cfs -pages] 4 "make sure we have 4 pages"
    assertEq [file attributes $cfs -metadata cookfs.smallfilebuffer] 30
    makeBinFile [randomData 8] "test7" $cfs
    makeBinFile [randomData 8] "test8" $cfs
    makeBinFile [randomData 8] "test9" $cfs
    makeBinFile [randomData 8] "test9.1" $cfs
    makeBinFile [randomData 8] "test9.2" $cfs
    assertEq [file attributes $cfs -pages] 5 "make sure we have 5 pages"
    cookfs::Unmount $cfs
    cookfs::Mount $cfs $cfs
    assertEq [file attributes $cfs -pages] 6 "make sure we have 6 pages"
} -cleanup {
    cookfs::Unmount $cfs
    catch { ::cookfs::c::reset_cache }
} -ok

cleanupTests

