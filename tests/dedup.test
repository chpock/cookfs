tcltest::test cookfsDedup-1.1 "Large file deduplication" -setup {
    set file [tcltest::makeFile {} pages.cfs]
} -body {
    set datas [randomDatas 4 8192]
    set c [cookfs::Mount $file $file -compression none \
        -pagesize 4096 -smallfilesize 1024]
    set i 0
    foreach d [concat $datas $datas [lrange $datas 2 14] [lrange $datas 7 15]] {
        set fh [open $file/d[incr i] w]
        fconfigure $fh -translation binary
        puts -nonewline $fh $d
        close $fh
    }
    cookfs::Unmount $file
    set fs [file size $file]
    expr {($fs > (2048 * 16)) && ($fs < (24 * 2048))}
} -cleanup {
    catch {cookfs::Unmount $file}
    tcltest::removeFile $file
    unset -nocomplain file datas c i fh fs d
} -result 1

tcltest::test cookfsDedup-1.2 "Small file deduplication for same resulting pages" -setup {
    set file [tcltest::makeFile {} pages.cfs]
} -body {
    set datas [randomDatas 16 2048]
    set c [cookfs::Mount $file $file -compression none \
        -pagesize 16384 -smallfilesize 16384 -smallfilebuffer 16384]
    set i 0
    foreach d [concat $datas $datas $datas $datas] {
        set fh [open $file/d[format "%02i" [incr i]] w]
        fconfigure $fh -translation binary
        puts -nonewline $fh $d
        close $fh
    }
    cookfs::Unmount $file
    set fs [file size $file]
    expr {($fs > (2048 * 16)) && ($fs < (24 * 2048))}
} -cleanup {
    catch {cookfs::Unmount $file}
    tcltest::removeFile $file
    unset -nocomplain file datas c i fh fs d
} -result 1

tcltest::test cookfsDedup-1.3 "Small file deduplication for different resulting pages" -constraints {enabledTclCmds} -setup {
    set file [tcltest::makeFile {} pages.cfs]
} -body {
    set datas [randomDatas 4 2048]
    set c [cookfs::Mount $file $file -compression none \
        -pagesize 4096 -smallfilesize 4096 -smallfilebuffer 16384]
    # datas is 4 files of 2048 bytes each
    # page has 4096 bytes
    # file1 contains datas#0 comes to page#0[0]
    # file2 contains datas#1 comes to page#0[1] - flush page now
    # file3 contains datas#2 comes to page#1[0]
    # file4 contains datas#0 uses page#0[0]
    # file5 contains datas#3 comes to page#1[1] - flush page now
    set files [list \
        file1 [lindex $datas 0] \
        file2 [lindex $datas 1] \
        file3 [lindex $datas 2] \
        file4 [lindex $datas 0] \
        file5 [lindex $datas 3] \
    ]
    foreach { f d } $files {
        set fh [open $file/$f w]
        fconfigure $fh -translation binary
        puts -nonewline $fh $d
        close $fh
    }
    cookfs::Unmount $file
    set fs [file size $file]
    set result [list]
    # the file size should be (2 pages + internal data) and less than (3 pages)
    lappend result [expr {($fs > (4096 * 2)) && ($fs < (4096 * 3))}]
    set c [cookfs::Mount -readonly $file $file]
    foreach { f d } $files {
        lappend result "$f [[$c getindex] get $f] [string equal $d [read [set fh [open $file/$f rb]]][close $fh]]"
    }
    join $result \n
} -cleanup {
    catch {cookfs::Unmount $file}
    tcltest::removeFile $file
    unset -nocomplain file datas c files f d fh fs result
} -match glob -result {1
file1 * 2048 {0 0 2048} 1
file2 * 2048 {0 2048 2048} 1
file3 * 2048 {1 0 2048} 1
file4 * 2048 {0 0 2048} 1
file5 * 2048 {1 2048 2048} 1}

tcltest::test cookfsDedup-1.4 "Small file deduplication for different resulting pages" -constraints {enabledTclCmds} -setup {
    set file [tcltest::makeFile {} pages.cfs]
} -body {
    set datas [randomDatas 3 2048]
    set c [cookfs::Mount $file $file -compression none \
        -pagesize 4096 -smallfilesize 4096 -smallfilebuffer 8192]
    # datas is 3 files of 2048 bytes each
    # page has 4096 bytes
    # file1 contains datas#0 comes to page#0[0]
    # file2 contains datas#1 comes to page#0[1] - flush page now
    # file3 contains datas#1 uses page#0[1]
    # file4 contains datas#1 uses page#0[1] - the buffer size of the small file
    #                                          has reached the limit and should be flushed.
    #                                          But only 1 page should be used for all 4 files.
    # file5 contains datas#0
    # file6 contains datas#1 - flush page now, but it appears the same page as #0,
    #                           so no new pages need to be created.
    # file7 contains data#1 uses page#0[1]
    # file8 contains data#2 uses page#1[0] - unmount now and flush page#1, even if it's not filled
    set files [list \
        file1 [lindex $datas 0] \
        file2 [lindex $datas 1] \
        file3 [lindex $datas 1] \
        file4 [lindex $datas 1] \
        file5 [lindex $datas 0] \
        file6 [lindex $datas 1] \
        file7 [lindex $datas 1] \
        file8 [lindex $datas 2] \
    ]
    foreach { f d } $files {
        set fh [open $file/$f w]
        fconfigure $fh -translation binary
        puts -nonewline $fh $d
        close $fh
    }
    cookfs::Unmount $file
    set fs [file size $file]
    set result [list]
    # the file size should be (1.5 pages + internal data) and less than (2 pages)
    lappend result [expr {($fs > (1.5 * 4096)) && ($fs < (4096 * 2))}]
    set c [cookfs::Mount -readonly $file $file]
    foreach { f d } $files {
        lappend result "$f [[$c getindex] get $f] [string equal $d [read [set fh [open $file/$f rb]]][close $fh]]"
    }
    join $result \n
} -cleanup {
    catch {cookfs::Unmount $file}
    tcltest::removeFile $file
    unset -nocomplain file datas c files f d fh fs result
} -match glob -result {1
file1 * 2048 {0 0 2048} 1
file2 * 2048 {0 2048 2048} 1
file3 * 2048 {0 2048 2048} 1
file4 * 2048 {0 2048 2048} 1
file5 * 2048 {0 0 2048} 1
file6 * 2048 {0 2048 2048} 1
file7 * 2048 {0 2048 2048} 1
file8 * 2048 {1 0 2048} 1}

tcltest::test cookfsDedup-2.1.1 "Check that new files can use pages from previously added files, with unmount" -constraints {enabledTclCmds enabledCWriter} -setup {
    # 4 chunks of 2048 bytes, total size: 8192 bytes
    set datas [randomDatas 4 2048]
    set vfs [tcltest::makeFile {} pages.cfs]
} -body {
    set result [list]
    # all files should be on the same page
    set h [cookfs::Mount $vfs $vfs -compression none -pagesize 8192 -smallfilesize 8192 -smallfilebuffer 8192]
    foreach idx {0 1 2 3} {
        set fd [open [file join $vfs "fileA$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    cookfs::Unmount $vfs
    # Mount the vfs again
    set h [cookfs::Mount $vfs $vfs -pagesize 8192 -smallfilesize 8192 -smallfilebuffer 8192]
    # Make sure we have only one page
    lappend result pg_len:[[$h getpages] length]
    # Add only 1st and 3rd files
    foreach idx {1 3} {
        set fd [open [file join $vfs "fileB$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    cookfs::Unmount $vfs
    # We expect size of archive as original 4 files of 2048 bytes + medatada.
    # It must be less than 5 files.
    lappend result size:[expr { [file size $vfs] > (4*2048) && [file size $vfs] < (5*2048) }]
    # Open the vfs again to make sure there are no new pages, and files are good
    set h [cookfs::Mount $vfs $vfs -readonly]
    # Make sure we have only one page still
    lappend result pg_len:[[$h getpages] length]
    foreach idx {1 3} {
        foreach suffix {A B} {
            lappend result match:[string equal [tcltest::viewBinFile "file$suffix$idx" $vfs] [lindex $datas $idx]]
        }
    }
    set result
} -cleanup {
    catch { cookfs::Unmount $vfs }
    tcltest::removeFile $vfs
    unset -nocomplain datas vfs idx fd h result suffix
} -result {pg_len:1 size:1 pg_len:1 match:1 match:1 match:1 match:1}

tcltest::test cookfsDedup-2.1.2 "Check that new files can use pages from previously added files, without unmount" -constraints {enabledTclCmds enabledCWriter} -setup {
    # 4 chunks of 2048 bytes, total size: 8192 bytes
    set datas [randomDatas 4 2048]
    set vfs [tcltest::makeFile {} pages.cfs]
} -body {
    set result [list]
    # all files should be on the same page
    set h [cookfs::Mount $vfs $vfs -compression none -pagesize 8192 -smallfilesize 8192 -smallfilebuffer 8192]
    foreach idx {0 1 2 3} {
        set fd [open [file join $vfs "fileA$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    # Make sure we have only one page
    lappend result pg_len:[[$h getpages] length]
    # Add only 1st and 3rd files
    foreach idx {1 3} {
        set fd [open [file join $vfs "fileB$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    cookfs::Unmount $vfs
    # We expect size of archive as original 4 files of 2048 bytes + medatada.
    # It must be less than 5 files.
    lappend result size:[expr { [file size $vfs] > (4*2048) && [file size $vfs] < (5*2048) }]
    # Open the vfs again to make sure there are no new pages, and files are good
    set h [cookfs::Mount $vfs $vfs -readonly]
    # Make sure we have only one page still
    lappend result pg_len:[[$h getpages] length]
    foreach idx {1 3} {
        foreach suffix {A B} {
            lappend result match:[string equal [tcltest::viewBinFile "file$suffix$idx" $vfs] [lindex $datas $idx]]
        }
    }
    set result
} -cleanup {
    catch { cookfs::Unmount $vfs }
    tcltest::removeFile $vfs
    unset -nocomplain datas vfs idx fd h result suffix
} -result {pg_len:1 size:1 pg_len:1 match:1 match:1 match:1 match:1}

tcltest::test cookfsDedup-2.1.3 "Check that new encrypted files don't use pages from previously added unencryted files" -constraints {enabledTclCmds enabledCWriter cookfsCrypto} -setup {
    # 4 chunks of 2048 bytes, total size: 8192 bytes
    set datas [randomDatas 4 2048]
    set vfs [tcltest::makeFile {} pages.cfs]
} -body {
    set result [list]
    # all files should be on the same page
    set h [cookfs::Mount $vfs $vfs -encryptlevel 0 -compression none -pagesize 8192 -smallfilesize 8192 -smallfilebuffer 8192]
    foreach idx {0 1 2 3} {
        set fd [open [file join $vfs "fileA$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    # Make sure we have only one page
    lappend result pg_len:[[$h getpages] length]
    $h password foo
    # Add only 1st and 3rd files
    foreach idx {1 3} {
        set fd [open [file join $vfs "fileB$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    cookfs::Unmount $vfs
    # We expect size of archive as original 4 files + 2 new files of 2048 bytes + medatada.
    lappend result size:[expr { [file size $vfs] > (6*2048) }]
    # Open the vfs again to make sure there are no new pages, and files are good
    set h [cookfs::Mount $vfs $vfs -readonly -password foo]
    # Make sure we have 2 pages still (1st page with 4 files and 2nd page with 2 encrypted files)
    lappend result pg_len:[[$h getpages] length]
    foreach idx {1 3} {
        foreach suffix {A B} {
            lappend result match:[string equal [tcltest::viewBinFile "file$suffix$idx" $vfs] [lindex $datas $idx]]
        }
    }
    set result
} -cleanup {
    catch { cookfs::Unmount $vfs }
    tcltest::removeFile $vfs
    unset -nocomplain datas vfs idx fd h result suffix
} -result {pg_len:1 size:1 pg_len:2 match:1 match:1 match:1 match:1}

tcltest::test cookfsDedup-2.1.4 "Check that new unencrypted files don't use pages from previously added encryted files" -constraints {enabledTclCmds enabledCWriter cookfsCrypto} -setup {
    # 4 chunks of 2048 bytes, total size: 8192 bytes
    set datas [randomDatas 4 2048]
    set vfs [tcltest::makeFile {} pages.cfs]
} -body {
    set result [list]
    # all files should be on the same page
    set h [cookfs::Mount $vfs $vfs -encryptlevel 0 -compression none -pagesize 8192 -smallfilesize 8192 -smallfilebuffer 8192]
    $h password foo
    foreach idx {0 1 2 3} {
        set fd [open [file join $vfs "fileA$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    # Make sure we have only one page
    lappend result pg_len:[[$h getpages] length]
    $h password ""
    # Add only 1st and 3rd files
    foreach idx {1 3} {
        set fd [open [file join $vfs "fileB$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    cookfs::Unmount $vfs
    # We expect size of archive as original 4 files + 2 new files of 2048 bytes + medatada.
    lappend result size:[expr { [file size $vfs] > (6*2048) }]
    # Open the vfs again to make sure there are no new pages, and files are good
    set h [cookfs::Mount $vfs $vfs -readonly -password foo]
    # Make sure we have 2 pages still (1st page with 4 files and 2nd page with 2 encrypted files)
    lappend result pg_len:[[$h getpages] length]
    foreach idx {1 3} {
        foreach suffix {A B} {
            lappend result match:[string equal [tcltest::viewBinFile "file$suffix$idx" $vfs] [lindex $datas $idx]]
        }
    }
    set result
} -cleanup {
    catch { cookfs::Unmount $vfs }
    tcltest::removeFile $vfs
    unset -nocomplain datas vfs idx fd h result suffix
} -result {pg_len:1 size:1 pg_len:2 match:1 match:1 match:1 match:1}

tcltest::test cookfsDedup-2.1.5 "Check that new encrypted files don't use pages from previously added cryted files" -constraints {enabledTclCmds enabledCWriter cookfsCrypto} -setup {
    # 4 chunks of 2048 bytes, total size: 8192 bytes
    set datas [randomDatas 4 2048]
    set vfs [tcltest::makeFile {} pages.cfs]
} -body {
    set result [list]
    # all files should be on the same page
    set h [cookfs::Mount $vfs $vfs -encryptlevel 0 -password foo -encryptkey -compression none -pagesize 8192 -smallfilesize 8192 -smallfilebuffer 8192]
    $h password foo
    foreach idx {0 1 2 3} {
        set fd [open [file join $vfs "fileA$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    # Make sure we have only one page
    lappend result pg_len:[[$h getpages] length]
    # Add only 1st and 3rd files
    foreach idx {1 3} {
        set fd [open [file join $vfs "fileB$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    cookfs::Unmount $vfs
    # We expect size of archive as original 4 files + 2 new files of 2048 bytes + medatada.
    lappend result size:[expr { [file size $vfs] > (6*2048) }]
    # Open the vfs again to make sure there are no new pages, and files are good
    set h [cookfs::Mount $vfs $vfs -readonly -password foo]
    # Make sure we have 2 pages still (1st page with 4 files and 2nd page with 2 encrypted files)
    lappend result pg_len:[[$h getpages] length]
    foreach idx {1 3} {
        foreach suffix {A B} {
            lappend result match:[string equal [tcltest::viewBinFile "file$suffix$idx" $vfs] [lindex $datas $idx]]
        }
    }
    set result
} -cleanup {
    catch { cookfs::Unmount $vfs }
    tcltest::removeFile $vfs
    unset -nocomplain datas vfs idx fd h result suffix
} -result {pg_len:1 size:1 pg_len:2 match:1 match:1 match:1 match:1}

tcltest::test cookfsDedup-2.2.1 "Check that new files can use pages from previously added and deleted files, with unmount" -constraints {enabledTclCmds enabledCWriter} -setup {
    # 10 chunks of 2048 bytes, total size: 20480 bytes
    set datas [randomDatas 10 2048]
    set vfs [tcltest::makeFile {} pages.cfs]
} -body {
    set result [list]
    # all files should be on the same page
    set h [cookfs::Mount $vfs $vfs -compression none -pagesize 20480 -smallfilesize 20480 -smallfilebuffer 20480]
    foreach idx {0 1 2 3 4 5 6 7 8 9} {
        set fd [open [file join $vfs "fileA$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    cookfs::Unmount $vfs
    # Mount the vfs again
    set h [cookfs::Mount $vfs $vfs -pagesize 20480 -smallfilesize 20480 -smallfilebuffer 20480]
    # Make sure we have only one page
    lappend result pg_len:[[$h getpages] length]
    # Remove 0th, 2nd, 4-5th, 9th files
    foreach idx {0 2 4 5 9} {
        file delete [file join $vfs "fileA$idx"]
    }
    cookfs::Unmount $vfs
    # Mount the vfs again
    set h [cookfs::Mount $vfs $vfs -pagesize 20480 -smallfilesize 20480 -smallfilebuffer 20480]
    # Add again all 10 files
    foreach idx {0 1 2 3 4 5 6 7 8 9} {
        set fd [open [file join $vfs "fileB$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    cookfs::Unmount $vfs
    # We expect that all "fileB*" files except 4th and 5th will reuse space from "fileA*" files.
    # The 4th and 5th files will be stored on a different page because the cookfs gap finder
    # will count 2 gaps from these files as one space.
    # Thus, we expect file size more than 12 files of 2048 bytes, but less than 13 files
    lappend result size:[expr { [file size $vfs] > (12*2048) && [file size $vfs] < (13*2048) }]
    # Open the vfs again to make sure there is 1 new page, and files are good
    set h [cookfs::Mount $vfs $vfs -readonly]
    # Make sure we have only one page still
    lappend result pg_len:[[$h getpages] length]
    foreach idx {0 1 2 3 4 5 6 7 8 9} {
        lappend result match:[string equal [tcltest::viewBinFile "fileB$idx" $vfs] [lindex $datas $idx]]
    }
    set result
} -cleanup {
    catch { cookfs::Unmount $vfs }
    tcltest::removeFile $vfs
    unset -nocomplain datas vfs idx fd h result
} -result {pg_len:1 size:1 pg_len:2 match:1 match:1 match:1 match:1 match:1 match:1 match:1 match:1 match:1 match:1}

tcltest::test cookfsDedup-2.2.2 "Check that new files can use pages from previously added and deleted files, without unmount" -constraints {enabledTclCmds enabledCWriter} -setup {
    # 10 chunks of 2048 bytes, total size: 20480 bytes
    set datas [randomDatas 10 2048]
    set vfs [tcltest::makeFile {} pages.cfs]
} -body {
    set result [list]
    # all files should be on the same page
    set h [cookfs::Mount $vfs $vfs -compression none -pagesize 20480 -smallfilesize 20480 -smallfilebuffer 20480]
    foreach idx {0 1 2 3 4 5 6 7 8 9} {
        set fd [open [file join $vfs "fileA$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    # Make sure we have only one page
    lappend result pg_len:[[$h getpages] length]
    # Remove 0th, 2nd, 4-5th, 9th files
    foreach idx {0 2 4 5 9} {
        file delete [file join $vfs "fileA$idx"]
    }
    # Add again all 10 files
    foreach idx {0 1 2 3 4 5 6 7 8 9} {
        set fd [open [file join $vfs "fileB$idx"] wb]
        puts -nonewline $fd [lindex $datas $idx]
        close $fd
    }
    cookfs::Unmount $vfs
    # This case is different from cookfsDedup-2.2.1. Here we don't unmount vfs,
    # thus we have correct page map. This means, that all "fileB*" files will use
    # space from previously created "fileA*" files.
    # So, we expect only 1 page, and file size should be more than 10 files of
    # 2048 bytes, but less than 11 files.
    lappend result size:[expr { [file size $vfs] > (10*2048) && [file size $vfs] < (11*2048) }]
    # Open the vfs again to make sure there is only one page, and files are good
    set h [cookfs::Mount $vfs $vfs -readonly]
    # Make sure we have only one page still
    lappend result pg_len:[[$h getpages] length]
    foreach idx {0 1 2 3 4 5 6 7 8 9} {
        lappend result match:[string equal [tcltest::viewBinFile "fileB$idx" $vfs] [lindex $datas $idx]]
    }
    set result
} -cleanup {
    catch { cookfs::Unmount $vfs }
    tcltest::removeFile $vfs
    unset -nocomplain datas vfs idx fd h result
} -result {pg_len:1 size:1 pg_len:1 match:1 match:1 match:1 match:1 match:1 match:1 match:1 match:1 match:1 match:1}


tcltest::test cookfsDedup-2.3.1 "Check dedup of small files which have the same md5 hash, with unmount" -constraints {enabledTclCmds enabledCWriter} -setup {
    set bin1 [binary decode hex 4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2]
    set bin2 [binary decode hex 4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2]
    set side [string repeat x [expr { 1024 - [string length $bin1] }]]
    set vfs [tcltest::makeFile {} pages.cfs]
} -body {
    set result [list]
    set h [cookfs::Mount $vfs $vfs -compression none -pagesize 1024 -smallfilesize 1024 -smallfilebuffer 1024]
    set fd [open [file join $vfs bin1] wb]
    puts -nonewline $fd $bin1
    close $fd
    set fd [open [file join $vfs side1] wb]
    puts -nonewline $fd $side
    close $fd
    cookfs::Unmount $vfs
    set h [cookfs::Mount $vfs $vfs -compression none -pagesize 1024 -smallfilesize 1024 -smallfilebuffer 1024]
    # Make sure we have only one page
    lappend result pg_len:[[$h getpages] length]
    # Add bin2 and side2 again. side2 will take the same space as side1, but bin2 should be
    # placed to separate page.
    set fd [open [file join $vfs bin2] wb]
    puts -nonewline $fd $bin2
    close $fd
    set fd [open [file join $vfs side2] wb]
    puts -nonewline $fd $side
    close $fd
    cookfs::Unmount $vfs
    # We expect archive size as bin1+bin2+side, but less than bin1+bin2+side+side.
    # bin1+side is 1024 bytes.
    lappend result size:[expr { [file size $vfs] > (1024 + [string length $bin2]) && [file size $vfs] < (1024 * 2) }]
    set h [cookfs::Mount $vfs $vfs -readonly]
    # Make sure we have only an additional page
    lappend result pg_len:[[$h getpages] length]
} -cleanup {
    catch { cookfs::Unmount $vfs }
    tcltest::removeFile $vfs
    unset -nocomplain bin1 bin2 side vfs fd result
} -result {pg_len:1 size:1 pg_len:2}

tcltest::test cookfsDedup-2.3.2 "Check dedup of small files which have the same md5 hash, without unmount" -constraints {enabledTclCmds enabledCWriter} -setup {
    # $bin1 and $bin2 have the same length and the same MD5 hash
    set bin1 [binary decode hex 4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2]
    set bin2 [binary decode hex 4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2]
    set side [string repeat x [expr { 1024 - [string length $bin1] }]]
    set vfs [tcltest::makeFile {} pages.cfs]
} -body {
    set result [list]
    set h [cookfs::Mount $vfs $vfs -compression none -pagesize 1024 -smallfilesize 1024 -smallfilebuffer 1024]
    set fd [open [file join $vfs bin1] wb]
    puts -nonewline $fd $bin1
    close $fd
    set fd [open [file join $vfs side1] wb]
    puts -nonewline $fd $side
    close $fd
    # Make sure we have only one page
    lappend result pg_len:[[$h getpages] length]
    # Add bin2 and side2 again. side2 will take the same space as side1, but bin2 should be
    # placed to separate page.
    set fd [open [file join $vfs bin2] wb]
    puts -nonewline $fd $bin2
    close $fd
    set fd [open [file join $vfs side2] wb]
    puts -nonewline $fd $side
    close $fd
    cookfs::Unmount $vfs
    # We expect archive size as bin1+bin2+side, but less than bin1+bin2+side+side.
    # bin1+side is 1024 bytes.
    lappend result size:[expr { [file size $vfs] > (1024 + [string length $bin2]) && [file size $vfs] < (1024 * 2) }]
    set h [cookfs::Mount $vfs $vfs -readonly]
    # Make sure we have only an additional page
    lappend result pg_len:[[$h getpages] length]
} -cleanup {
    catch { cookfs::Unmount $vfs }
    tcltest::removeFile $vfs
    unset -nocomplain bin1 bin2 side vfs fd result
} -result {pg_len:1 size:1 pg_len:2}




